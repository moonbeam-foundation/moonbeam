# PR #7375: Refactor the host <-> runtime interface machinery

**PR Link**: https://github.com/paritytech/polkadot-sdk/pull/7375
**Labels**: T17-primitives
**Impact Level**: üî¥ **HIGH - BREAKING CHANGES REQUIRED**

---

## Summary

This PR fundamentally refactors the `#[runtime_interface]` macro system to make type marshalling strategies explicit instead of implicit. Previously, how types were passed across the host-runtime boundary was hardcoded through trait implementations. Now, marshalling strategies are explicitly specified using wrapper types like `PassFatPointerAndRead<T>`.

**Key Change**:
```rust
// Before
#[runtime_interface]
trait MyInterface {
    fn say_hello_world(name: &str) { }
}

// After
#[runtime_interface]
trait MyInterface {
    fn say_hello_world(name: PassFatPointerAndRead<&str>) { }
}
```

---

## Affected Crates

| Crate | Bump Type | Note |
|-------|-----------|------|
| `sp-runtime-interface` | **major** | Complete rework of `#[runtime_interface]` macro |
| `sp-runtime-interface-proc-macro` | **major** | Rework of macro implementation |
| `sp-wasm-interface` | **major** | `Pointer` type now implements `Copy`/`Clone` unconditionally |
| `sp-core` | **major** | Some types no longer implement old runtime interface traits |
| `sp-io` | **major** | Requires new macro and associated machinery |
| `sp-statement-store` | **major** | Requires new macro and associated machinery |
| `sp-crypto-ec-utils` | minor | Requires new macro and associated machinery |
| `frame-benchmarking` | **major** | `Benchmarking::current_time` host call changed |
| `frame-support-procedural` | minor | Updated for new `frame-benchmarking` |
| `polkadot-runtime-metrics` | minor | Updated for new `frame-benchmarking` |

---

## Impact on Moonbeam

### üî¥ CRITICAL: Custom Runtime Interface Definitions

**File**: `/Users/manuelmauro/Workspace/moonbeam/primitives/ext/src/lib.rs`

Moonbeam defines a custom `#[runtime_interface]` trait called `MoonbeamExt` with the following host functions:

```rust
#[runtime_interface]
pub trait MoonbeamExt {
    fn raw_step(&mut self, _data: Vec<u8>) {}
    fn raw_gas(&mut self, _data: Vec<u8>) {}
    fn raw_return_value(&mut self, _data: Vec<u8>) {}
    fn call_list_entry(&mut self, _index: u32, _value: Vec<u8>) {}
    fn call_list_new(&mut self) {}
    fn evm_event(&mut self, event: Vec<u8>) { }
    fn gasometer_event(&mut self, event: Vec<u8>) { }
    fn runtime_event(&mut self, event: Vec<u8>) { }
    fn step_event_filter(&self) -> StepEventFilter { }

    #[version(2)]
    fn call_list_new(&mut self) { }
}
```

**Required Changes**:
All function parameters must be updated to use explicit marshalling strategies:

- `Vec<u8>` parameters ‚Üí Need explicit strategy (likely `PassFatPointerAndRead<Vec<u8>>` or `PassFatPointerAndDecode<Vec<u8>>`)
- `u32` parameters ‚Üí Need explicit strategy (likely `PassAs<u32, u32>`)
- Return types like `StepEventFilter` ‚Üí Need explicit strategy (likely `AllocateAndReturnByCodec<StepEventFilter>` or similar)

**Example Migration**:
```rust
// Before
fn evm_event(&mut self, event: Vec<u8>) {
    if let Ok(event) = EvmEvent::decode(&mut &event[..]) {
        Event::Evm(event).emit();
    }
}

// After (estimated)
fn evm_event(&mut self, event: PassFatPointerAndRead<Vec<u8>>) {
    if let Ok(event) = EvmEvent::decode(&mut &event[..]) {
        Event::Evm(event).emit();
    }
}
```

**Note**: The actual function body remains unchanged. The `#[runtime_interface]` macro automatically strips the marshalling wrappers, so only the signature changes.

---

### üü° MODERATE: PassByCodec Usage

**File**: `/Users/manuelmauro/Workspace/moonbeam/primitives/rpc/evm-tracing-events/src/lib.rs`

This file uses `PassByCodec` from `sp-runtime-interface::pass_by`:

```rust
use sp_runtime_interface::pass_by::PassByCodec;

#[derive(Clone, Copy, Eq, PartialEq, Debug, Encode, Decode, Default, PassByCodec)]
pub struct StepEventFilter {
    pub enable_stack: bool,
    pub enable_memory: bool,
}
```

**Impact**: The `PassByCodec` derive macro may have changed behavior or been deprecated in favor of explicit marshalling strategies. This needs to be verified during the upgrade.

**Action Required**:
- Review if `PassByCodec` is still supported or if it needs migration
- Test that `StepEventFilter` serialization/deserialization still works correctly

---

### üü¢ LOW: Compilation Mode Changes

**All Runtime Code**

The PR introduces `#[cfg(substrate_runtime)]` as a replacement for `#[cfg(not(feature = "std"))]` to explicitly distinguish runtime compilation mode.

**Impact**: Moonbeam's runtime code may need updates if it uses `#[cfg(not(feature = "std"))]` for runtime-specific logic.

**Action Required**:
- Search for `#[cfg(not(feature = "std"))]` patterns in runtime code
- Consider migrating to `#[cfg(substrate_runtime)]` for clarity
- Verify runtime WASM compilation succeeds

---

### üü¢ LOW: Indirect Dependencies

**All Pallets, Precompiles, and Runtime Components**

Moonbeam extensively uses affected crates:
- `sp-io`: Used in 45+ Cargo.toml files
- `sp-core`: Used in 45+ Cargo.toml files
- `frame-benchmarking`: Used in 14+ pallets and runtime crates

**Impact**: These are internal implementation details managed by Polkadot SDK. No direct code changes should be required unless Moonbeam uses internal/unstable APIs.

**Benchmarking Changes**:
The PR modifies `Benchmarking::current_time()` host function signature, but this is an internal change. Moonbeam's benchmarking code uses the standard `frame_benchmarking::define_benchmarks!` macro, which should handle the change automatically:

```rust
// From runtime/moonbase/src/lib.rs
frame_benchmarking::define_benchmarks!(
    [frame_system, SystemBench::<Runtime>]
    [pallet_balances, Balances]
    [pallet_parachain_staking, ParachainStaking]
    // ... other pallets
);
```

**Action Required**:
- Run full benchmark suite after upgrade to verify no regressions
- Check that custom benchmark implementations (if any) still compile

---

## Required Actions

### 1. Update Custom Runtime Interface (CRITICAL)
- [ ] Migrate `MoonbeamExt` trait in `/Users/manuelmauro/Workspace/moonbeam/primitives/ext/src/lib.rs`
- [ ] Add explicit marshalling strategies to all function parameters
- [ ] Add explicit return strategies to all return types
- [ ] Verify the runtime still compiles in WASM mode

### 2. Review PassByCodec Usage (MODERATE)
- [ ] Check if `PassByCodec` in `/Users/manuelmauro/Workspace/moonbeam/primitives/rpc/evm-tracing-events/src/lib.rs` needs migration
- [ ] Test EVM tracing functionality after upgrade
- [ ] Verify `StepEventFilter` serialization works correctly

### 3. Test Compilation Modes (LOW)
- [ ] Search for `#[cfg(not(feature = "std"))]` usage in runtime code
- [ ] Verify WASM runtime compilation succeeds
- [ ] Consider migrating to `#[cfg(substrate_runtime)]` for clarity

### 4. Verify Benchmarks (LOW)
- [ ] Run full benchmark suite: `./scripts/run-benches-for-runtime.sh moonbase release`
- [ ] Verify no regressions in benchmark output
- [ ] Test custom pallet benchmarks compile and run

### 5. Integration Testing (CRITICAL)
- [ ] Test EVM tracing functionality (uses custom host functions)
- [ ] Run full integration test suite: `pnpm moonwall test dev_moonbase`
- [ ] Verify EVM events, gasometer events, and runtime events are captured correctly
- [ ] Test both raw and calllist tracing modes

---

## Migration Strategy

### Phase 1: Code Updates
1. Update `primitives/ext/src/lib.rs` with explicit marshalling strategies
2. Review and update `primitives/rpc/evm-tracing-events/src/lib.rs` if needed
3. Search and replace `#[cfg(not(feature = "std"))]` if necessary

### Phase 2: Compilation Verification
1. Build all runtimes: `cargo build --release -p moonbeam-runtime -p moonriver-runtime -p moonbase-runtime`
2. Verify WASM builds succeed
3. Check for any compilation warnings related to runtime interfaces

### Phase 3: Testing
1. Unit tests: `cargo test`
2. Benchmarks: `./scripts/run-benches-for-runtime.sh moonbase release`
3. Integration tests: `cd test && pnpm moonwall test dev_moonbase`
4. Smoke tests: `pnpm moonwall test smoke_moonbase`
5. Manual EVM tracing tests

### Phase 4: Documentation
1. Document the marshalling strategy choices made
2. Update any internal documentation about custom host functions
3. Add migration notes for future reference

---

## Risk Assessment

**Overall Risk**: üî¥ **HIGH**

**Risk Factors**:
1. **Breaking API Changes**: The `#[runtime_interface]` macro API has fundamentally changed
2. **Custom Host Functions**: Moonbeam has custom host functions that must be manually migrated
3. **EVM Tracing Critical Path**: The affected code is in the critical EVM tracing path
4. **Runtime-Client Interface**: Changes affect the boundary between runtime and client

**Mitigation**:
- Thorough testing of EVM tracing functionality
- Benchmark all pallets to catch performance regressions
- Run full integration test suite multiple times
- Manual testing of trace RPC endpoints

---

## References

- **PRDoc**: `/Users/manuelmauro/.substrate-mcp/moonbeam/releases/stable2506/pr-docs/pr_7375.prdoc`
- **Affected Files**:
  - `/Users/manuelmauro/Workspace/moonbeam/primitives/ext/src/lib.rs` (CRITICAL)
  - `/Users/manuelmauro/Workspace/moonbeam/primitives/rpc/evm-tracing-events/src/lib.rs` (MODERATE)
  - `/Users/manuelmauro/Workspace/moonbeam/primitives/ext/Cargo.toml`
  - `/Users/manuelmauro/Workspace/moonbeam/primitives/rpc/evm-tracing-events/Cargo.toml`
  - All runtime Cargo.toml files (indirect)

---

## Additional Notes

### Enum Discriminant Warning
The PRDoc includes this important note:

> Please pay attention that `enum`s with explicit discriminant numbers (if different from implicit, that is, not starting from zero or not sequential) using the old `PassByEnum` strategy, should be carefully migrated to preserve compatibility, as `PassByEnum` was always using implicitly generated discriminants starting from zero, and the `PassAs` strategy introduced by this PR passes actual values.

**Action**: Review if any Moonbeam custom types passed through runtime interfaces use enums with explicit discriminants.

### Performance Considerations
The PR mentions that the old implicit marshalling masked expensive operations:

> It was not obvious how a given type is going to be passed just by looking at its type alone, masking potentially expensive marshalling strategies. (For example, returning `Option<u32>` was done through the SCALE codec and involved extra memory allocations!)

With explicit marshalling strategies, the performance characteristics become clear. This is actually a benefit as it makes the cost of marshalling visible in the code.

---

**Analysis Date**: 2025-10-23
**Analyzer**: Claude Code
**Status**: ‚ö†Ô∏è REQUIRES MANUAL MIGRATION
