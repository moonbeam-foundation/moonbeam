# PR #7682 Impact Analysis: SharedTrieCache/LocalTrieCache Memory Optimization

## PR Overview

**Title:** Make SharedTrieCache/LocalTrieCache work with entire state in memory

**GitHub:** https://github.com/paritytech/polkadot-sdk/pull/7682

**Labels:** T0-node

**Status:** Merged (May 14, 2025)

## Summary

This PR enhances the trie cache system to work under the assumption that the majority of the blockchain state can fit into memory. It introduces configurable cache sizes and dual cache modes: trusted (for block authoring/importing) and untrusted (for external operations). The trusted mode allows unbounded cache growth to hold complete block data, then propagates all entries to the shared cache.

## Technical Changes

### Core API Changes

1. **New `TrieCacheContext` Enum** (in `sc-client-api`)
   - Two variants: `Trusted` and `Untrusted`
   - Implements `From<CallContext>` mapping:
     - `CallContext::Onchain` → `TrieCacheContext::Trusted`
     - `CallContext::Offchain` → `TrieCacheContext::Untrusted`

2. **`Backend::state_at()` Signature Change**
   ```rust
   // OLD
   fn state_at(&self, hash: Block::Hash) -> sp_blockchain::Result<Self::State>

   // NEW
   fn state_at(
       &self,
       hash: Block::Hash,
       trie_cache_context: TrieCacheContext
   ) -> sp_blockchain::Result<Self::State>
   ```

3. **SharedTrieCache API Changes** (in `sp-trie`)
   - `SharedTrieCache::new()` accepts new parameter for unlimited cache configuration
   - `local_cache()` renamed to `local_cache_untrusted()`
   - New `local_cache_trusted()` method for trusted contexts

### Affected Crates (Major Version Bumps)

- `sp-state-machine` - State management primitives
- `sp-trie` - Trie data structures
- `sc-client-api` - Client APIs
- `sc-client-db` - Database layer
- `cumulus-pallet-parachain-system` - Parachain system pallet
- `sc-cli` - CLI components
- `sc-service` - Service components
- `sc-basic-authorship` - Block authoring
- `cumulus-relay-chain-inprocess-interface` - Relay chain interface
- `frame-benchmarking-cli` - Benchmarking CLI
- `substrate-state-trie-migration-rpc` - State trie migration RPC
- `sc-consensus-beefy` - BEEFY consensus

## Impact on Moonbeam

### Severity: CRITICAL - BREAKING CHANGES REQUIRED

### Affected Components

#### 1. Custom Backend Implementation

**File:** `/Users/manuelmauro/Workspace/moonbeam/node/service/src/lazy_loading/substrate_backend.rs`

Moonbeam implements a custom lazy-loading backend for the development mode that fetches state from a remote RPC endpoint. This custom implementation will break with this PR.

**Required Changes:**

**Line 1333** - Update trait method signature:
```rust
// CURRENT
fn state_at(&self, hash: Block::Hash) -> sp_blockchain::Result<Self::State> {

// REQUIRED UPDATE
fn state_at(
    &self,
    hash: Block::Hash,
    trie_cache_context: TrieCacheContext
) -> sp_blockchain::Result<Self::State> {
```

**Line 1234** - Update call in `begin_operation()`:
```rust
// CURRENT
let old_state = self.state_at(Default::default())?;

// SUGGESTED UPDATE (assuming trusted context for block operations)
let old_state = self.state_at(Default::default(), TrieCacheContext::Trusted)?;
```

**Line 1252** - Update call in `begin_state_operation()`:
```rust
// CURRENT
operation.old_state = self.state_at(block)?;

// SUGGESTED UPDATE
operation.old_state = self.state_at(block, TrieCacheContext::Trusted)?;
```

**Line 1362** - Update call in `state_at()` internal logic:
```rust
// CURRENT
let parent = self.state_at(*header.parent_hash()).ok();

// SUGGESTED UPDATE
let parent = self.state_at(*header.parent_hash(), TrieCacheContext::Trusted).ok();
```

**Additional Required Import:**
```rust
use sc_client_api::backend::TrieCacheContext;
```

#### 2. Dependencies

**File:** `/Users/manuelmauro/Workspace/moonbeam/node/service/Cargo.toml`

The service crate depends on multiple affected crates:
- `sc-client-api` (line 58)
- `sc-client-db` (line 59)
- `sc-basic-authorship` (line 56)
- `sc-service` (line 68)
- `sp-state-machine` (line 90)
- `sp-trie` (line 89)
- `cumulus-relay-chain-inprocess-interface` (line 123)

All these dependencies will receive major version bumps.

#### 3. Runtime Impact

**Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/Cargo.toml`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/Cargo.toml`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/Cargo.toml`

All three runtimes depend on `cumulus-pallet-parachain-system` which received a major bump. While the pallet itself may not require code changes (the changes are likely in the pallet's internal dependencies), the major version bump indicates potential for breaking changes.

### Context Determination

For the Moonbeam lazy-loading backend, the appropriate `TrieCacheContext` should be:

- **`Trusted`** for:
  - Block authoring operations (`begin_operation`, `begin_state_operation`)
  - Block import operations
  - Internal state operations during block production
  - State access in recursive calls (line 1362)

- **`Untrusted`** for:
  - External RPC queries
  - User-initiated state queries
  - Off-chain operations

Since all the identified `state_at()` calls in the lazy-loading backend are used in block import/production contexts, they should all use `TrieCacheContext::Trusted`.

## Migration Path

### Step 1: Update Custom Backend Implementation

1. Add import for `TrieCacheContext`
2. Update `state_at()` method signature to accept the new parameter
3. Update all internal calls to `state_at()` to pass `TrieCacheContext::Trusted`
4. Consider if any external-facing APIs need to propagate this parameter

### Step 2: Update Dependencies

The Cargo dependencies will be automatically updated when upgrading to stable2506. Verify that:
- All affected crates have compatible versions
- No other breaking changes exist in the updated crates
- Cargo.lock is updated correctly

### Step 3: Testing

Focus testing on:
1. **Lazy Loading Mode**: Verify the custom backend still works correctly
   - Start node with lazy loading configuration
   - Verify state can be fetched from remote RPC
   - Test block production and import

2. **Normal Mode**: Verify standard backend operations
   - Block authoring
   - Block import
   - State queries

3. **Cache Performance**: Monitor if the new caching behavior impacts performance
   - Check memory usage with the new unlimited cache mode
   - Verify cache hit rates are acceptable

### Step 4: Compilation Verification

```bash
# Build the node with lazy-loading feature
cargo build --release --features lazy-loading

# Build all runtimes
cargo build --release -p moonbase-runtime
cargo build --release -p moonbeam-runtime
cargo build --release -p moonriver-runtime

# Run tests
cargo test -p moonbeam-service
```

## Performance Implications

### Benefits

1. **Reduced Database Lookups**: The trusted cache can expand to hold complete block state, reducing disk I/O during block authoring and validation
2. **Better Cache Propagation**: All cached data from trusted contexts propagates to the shared cache
3. **Improved Collator Performance**: Critical for parachain collators during block production

### Considerations

1. **Memory Usage**: Trusted contexts can grow unbounded, potentially increasing memory consumption during block production
2. **Lazy Loading Backend**: May need additional memory tuning for the in-memory state cache when fetching from remote RPC

## Risk Assessment

**Risk Level:** MEDIUM-HIGH

### Risks

1. **Breaking Compilation**: The API changes are breaking and will cause compilation failures until addressed
2. **Runtime Behavior**: Changes to cache behavior could affect state access patterns
3. **Memory Consumption**: Unbounded cache growth in trusted contexts could increase memory usage
4. **Lazy Loading Compatibility**: Custom backend implementation needs careful updating to maintain functionality

### Mitigation

1. **Thorough Testing**: Extensive testing of the lazy-loading backend after changes
2. **Memory Monitoring**: Monitor memory usage in both trusted and untrusted contexts
3. **Gradual Rollout**: Test on development network before production deployment
4. **Cache Metrics**: Use the new instrumentation to verify cache behavior

## Recommended Actions

### Immediate (Pre-Upgrade)

1. Review the custom lazy-loading backend implementation
2. Plan the update strategy for `state_at()` calls
3. Set up test scenarios for lazy-loading mode
4. Document current memory usage patterns for comparison

### During Upgrade

1. Update the custom `Backend` trait implementation
2. Add `TrieCacheContext` parameter to all `state_at()` calls
3. Verify compilation across all features
4. Run unit tests and integration tests

### Post-Upgrade

1. Monitor memory usage patterns with the new cache behavior
2. Verify lazy-loading mode functionality
3. Check cache hit rates and performance metrics
4. Document any behavioral changes observed

## Additional Notes

- The PR was tested on Kusama Asset Hub collators before merging, demonstrating its suitability for production parachain environments
- The `CallContext` type used in `/Users/manuelmauro/Workspace/moonbeam/node/service/src/lazy_loading/call_executor.rs` is separate from `TrieCacheContext` and does not need updating
- The change improves the node-level infrastructure but doesn't affect runtime logic directly
- ParachainSystem pallet usage in runtimes should continue to work without code changes (only dependency version updates needed)

## Conclusion

PR #7682 introduces beneficial performance improvements for state caching but requires breaking changes to Moonbeam's custom lazy-loading backend. The changes are localized to the `state_at()` method and its call sites. With proper updates and testing, this PR should provide performance benefits for block production and import operations.

**Upgrade Priority:** HIGH - Required for stable2506 compatibility

**Estimated Effort:** MEDIUM - Straightforward API updates but requires careful testing of lazy-loading functionality
