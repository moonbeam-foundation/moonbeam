# PR #7682: Make SharedTrieCache/LocalTrieCache work with entire state in memory

## Overview

**PR:** https://github.com/paritytech/polkadot-sdk/pull/7682
**Labels:** T0-node
**Audience:** Node Developers
**Impact:** Non-Breaking (Internal Optimization)

## Summary

This PR extends the `LocalTrieCache` with a "trusted configuration" that can hold the entire state in memory during block authoring and import operations, then propagate this data back to the `SharedTrieCache`. This optimization improves performance by removing size limits on the trie cache during critical operations.

## Changes

### Key Modifications

1. **Configurable LocalTrieCache**: Removed hard-coded size limits, allowing external configuration of cache capacity
2. **Dual Cache Flavors**: Introduced trusted and untrusted cache variants
   - Trusted caches (for authoring/import) grow unbounded to hold complete block state
   - Data propagates to shared cache upon drop
3. **Efficient Propagation**: Direct data transfer from LocalTrieCache to SharedTrieCache without separate worker threads
4. **Metrics Addition**: Added monitoring to track cache hit/miss rates

### Affected Crates (All Major Bumps)

#### Core State Machine Crates
- **sp-state-machine**: Low-level state machine primitives
- **sp-trie**: Trie database implementation

#### Client Crates
- **sc-client-api**: Client API interfaces
- **sc-client-db**: Database backend implementation
- **sc-service**: Service configuration and initialization
- **sc-cli**: Command-line interface utilities
- **sc-basic-authorship**: Block authoring logic
- **sc-consensus-beefy**: BEEFY consensus (not used by Moonbeam)

#### Cumulus Crates
- **cumulus-pallet-parachain-system**: Core parachain pallet
- **cumulus-relay-chain-inprocess-interface**: Relay chain interface

#### Utility Crates
- **frame-benchmarking-cli**: Benchmarking command-line tools
- **substrate-state-trie-migration-rpc**: State migration RPC (deprecated in Moonbeam)

## Impact on Moonbeam

### Classification

**Category:** Non-Breaking Internal Optimization
**Type:** Node-level changes (T0-node)
**Action Required:** None (automatic on upgrade)

### Affected Components

#### 1. Runtime Configuration (Indirect Impact)

All three Moonbeam runtimes include `cumulus-pallet-parachain-system`:

**Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/Cargo.toml` (line 155)
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/Cargo.toml`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/Cargo.toml`

**Runtime Configuration:**
```rust
// /Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/lib.rs:750
impl cumulus_pallet_parachain_system::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnSystemEvent = ();
    type SelfParaId = ParachainInfo;
    type ReservedDmpWeight = ReservedDmpWeight;
    type OutboundXcmpMessageSource = XcmpQueue;
    type XcmpMessageHandler = XcmpQueue;
    type ReservedXcmpWeight = ReservedXcmpWeight;
    type CheckAssociatedRelayNumber = EmergencyParaXcm;
    type ConsensusHook = ConsensusHook;
    type DmpQueue = frame_support::traits::EnqueueWithOrigin<MessageQueue, RelayOrigin>;
    type WeightInfo = moonbase_weights::cumulus_pallet_parachain_system::WeightInfo<Runtime>;
    type SelectCore = cumulus_pallet_parachain_system::DefaultCoreSelector<Runtime>;
}
```

The pallet is used throughout the runtime for:
- Runtime upgrades (via `ParachainSystem::ValidationData`, `ParachainSystem::PendingValidationCode`)
- XCM message handling (via `ParachainSystem::HostConfiguration`, `ParachainSystem::PendingUpwardMessages`)
- Relay chain state verification (via `ParachainSystem::RelayStateProof`)

#### 2. Block Authoring (Direct Impact)

**Primary Impact Area:** This is where the PR's optimizations will be most beneficial.

**Collator Service Configuration:**
```rust
// /Users/manuelmauro/Workspace/moonbeam/node/service/src/lib.rs:1011
let proposer_factory = sc_basic_authorship::ProposerFactory::with_proof_recording(
    task_manager.spawn_handle(),
    client.clone(),
    transaction_pool,
    prometheus_registry,
    telemetry.clone(),
);

let proposer = Proposer::new(proposer_factory);
```

**Dev Mode Manual Sealing:**
```rust
// /Users/manuelmauro/Workspace/moonbeam/node/service/src/lib.rs:1231
if collator {
    let mut env = sc_basic_authorship::ProposerFactory::with_proof_recording(
        task_manager.spawn_handle(),
        client.clone(),
        transaction_pool.clone(),
        prometheus_registry.as_ref(),
        telemetry.as_ref().map(|x| x.handle()),
    );
    env.set_soft_deadline(SOFT_DEADLINE_PERCENT);
    // ... manual sealing setup
}
```

Both authoring paths now benefit from the unbounded trie cache during block production.

#### 3. Client Service (Direct Impact)

**Service Dependencies:**
```toml
# /Users/manuelmauro/Workspace/moonbeam/node/service/Cargo.toml
sc-basic-authorship = { workspace = true }     # Line 56
sc-client-api = { workspace = true }           # Line 58
sc-client-db = { workspace = true }            # Line 59
sc-service = { workspace = true }              # Line 68
sp-state-machine = { workspace = true }        # Line 90
sp-trie = { workspace = true, features = ["std"] }  # Line 89
cumulus-relay-chain-inprocess-interface = { workspace = true }  # Line 123
```

**Service Initialization:**
```rust
// /Users/manuelmauro/Workspace/moonbeam/node/service/src/lib.rs:525
let (client, backend, keystore_container, task_manager) =
    sc_service::new_full_parts_record_import::<Block, RuntimeApi, _>(
        config,
        telemetry.as_ref().map(|(_, telemetry)| telemetry.handle()),
        executor,
        true,  // enable import recording
    )?;
```

The `new_full_parts_record_import` function now utilizes the improved trie cache for import operations.

#### 4. Custom Backend Implementation (Direct Impact)

Moonbeam has a custom lazy-loading backend that directly uses the affected crates:

**File:** `/Users/manuelmauro/Workspace/moonbeam/node/service/src/lazy_loading/substrate_backend.rs`

```rust
// Lines 24-26
use sp_state_machine::{
    BackendTransaction, ChildStorageCollection, IndexOperation, StorageCollection, TrieBackend,
};
// Line 53
use sp_trie::PrefixedMemoryDB;
```

This custom backend interacts with the state machine and trie structures. The PR's changes to sp-state-machine and sp-trie are internal optimizations that should be transparent to this code.

#### 5. Call Executor (Direct Impact)

**File:** `/Users/manuelmauro/Workspace/moonbeam/node/service/src/lazy_loading/call_executor.rs`

```rust
// Line 22
use sp_state_machine::{OverlayedChanges, StorageProof};
```

The call executor uses `OverlayedChanges` which benefits from the improved trie caching during execution.

#### 6. CLI and Benchmarking (Direct Impact)

**CLI Dependencies:**
```toml
# /Users/manuelmauro/Workspace/moonbeam/node/cli/Cargo.toml
frame-benchmarking-cli = { workspace = true }  # Line 20
sc-cli = { workspace = true }                   # Line 21
```

**Benchmarking Usage:**
```rust
// /Users/manuelmauro/Workspace/moonbeam/node/cli/src/command.rs:22
use frame_benchmarking_cli::{BenchmarkCmd, SUBSTRATE_REFERENCE_HARDWARE};

// Used for pallet, block, storage, and machine benchmarking
BenchmarkCmd::Pallet(cmd) => { ... }
BenchmarkCmd::Block(cmd) => { ... }
BenchmarkCmd::Storage(cmd) => { ... }
BenchmarkCmd::Machine(cmd) => { ... }
```

Benchmarking operations, especially storage and pallet benchmarks, will benefit from improved trie caching.

## Benefits for Moonbeam

### Performance Improvements

1. **Block Authoring Efficiency**
   - Reduced cache misses during block production
   - Faster state access for collators
   - Particularly beneficial for Moonbeam's EVM execution which requires extensive state reads

2. **Block Import Performance**
   - Improved validation speed
   - Better cache utilization during sync
   - Faster recovery from network disruptions

3. **Benchmarking Accuracy**
   - More consistent benchmark results
   - Reduced variance from cache behavior
   - Better weight estimation for extrinsics

4. **Memory Management**
   - More predictable memory usage patterns
   - Efficient cache propagation
   - No additional worker threads needed

### Moonbeam-Specific Considerations

**EVM State Access:** Moonbeam's EVM pallet performs extensive state reads during smart contract execution. The unbounded trie cache during block authoring means:
- EVM state reads during transaction execution will have better cache hits
- Contract calls that access multiple storage slots benefit from the full state in memory
- Gas estimation for complex contracts becomes more predictable

**XCM Operations:** Cross-chain message processing involves:
- Reading `ParachainSystem::ValidationData`
- Updating `ParachainSystem::PendingUpwardMessages`
- Accessing relay chain state proofs

All these operations benefit from the improved caching during block production.

## Verification Testing

### Recommended Tests

1. **Block Authoring Performance**
   ```bash
   # Test dev node block production
   ./target/release/moonbeam --dev --alice --sealing 6000

   # Monitor block production times
   # Check for improvements in authoring duration
   ```

2. **Sync Performance**
   ```bash
   # Sync from scratch and measure time
   # Compare before/after upgrade
   ```

3. **Benchmarking Consistency**
   ```bash
   # Run pallet benchmarks multiple times
   ./scripts/run-benches-for-runtime.sh moonbase release

   # Compare variance in results
   ```

4. **EVM Contract Execution**
   ```typescript
   // test/suites/dev/moonbase/test-contract/
   // Run complex contract tests and measure gas usage consistency
   pnpm moonwall test dev_moonbase
   ```

5. **Memory Monitoring**
   ```bash
   # Monitor RSS/VSZ during block production
   # Verify memory usage patterns are stable
   ```

## Risk Assessment

### Risk Level: **LOW**

**Justification:**
1. **Internal Implementation**: Changes are internal to the trie cache mechanism
2. **Battle Tested**: Validated on Kusama Asset Hub collators (April 28 - May 14, 2025)
3. **No API Changes**: All crate bumps are for internal improvements
4. **Backward Compatible**: No configuration changes required
5. **Transparent Operation**: Existing code continues to work without modifications

### Potential Issues

1. **Memory Usage Increase** (Low Probability)
   - **Issue**: Unbounded cache during authoring might use more memory for very large blocks
   - **Mitigation**: PR design accounts for "more or less entire state fits in memory" assumption
   - **Moonbeam Context**: Block size limits and state access patterns make this unlikely

2. **Cache Propagation Overhead** (Very Low Probability)
   - **Issue**: Propagating large caches back to shared cache could cause delays
   - **Mitigation**: PR states "processing volumes remain manageable"
   - **Monitoring**: Check for any delays in block finalization

## Migration Guide

### Required Actions

**NONE** - This PR requires no code changes, configuration updates, or migration steps.

### Optional Actions

1. **Monitor Metrics**
   - If your deployment has Prometheus enabled, monitor for new trie cache metrics
   - Look for improvements in cache hit rates
   - Track memory usage patterns

2. **Performance Baseline**
   - Record current block authoring times before upgrade
   - Compare post-upgrade to quantify improvements

3. **Testing**
   - Run existing integration tests to verify compatibility
   - Test collator operations in staging environment

## Related PRs and Issues

- **Fixes:** polkadot-sdk#7534
- **Related:** polkadot-sdk#6131
- **Monitoring Dashboard:** https://grafana.teleport.parity.io/

## Conclusion

PR #7682 is a **non-breaking internal optimization** that improves trie cache behavior during block authoring and import operations. Moonbeam will benefit automatically from:

1. **Faster block authoring** through improved cache hit rates
2. **Better EVM execution performance** due to efficient state access
3. **More predictable benchmarking** results
4. **Improved sync performance** during chain synchronization

**No action is required** from the Moonbeam team. The changes are transparent and should result in measurable performance improvements, particularly in collator operations and EVM contract execution.

### Recommendation

**APPROVE** - This PR can be safely integrated into the stable2506 upgrade with no concerns. The optimizations align well with Moonbeam's architecture and should provide tangible performance benefits.
