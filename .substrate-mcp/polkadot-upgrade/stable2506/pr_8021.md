# PR #8021: XCMP: Use Batching When Enqueuing Inbound Messages

## Overview

**PR Link:** https://github.com/paritytech/polkadot-sdk/pull/8021
**Labels:** T6-XCM, I9-optimisation
**Impact Level:** HIGH - Direct performance improvement with breaking API changes

This PR implements batching for XCMP (Cross-Chain Message Passing) inbound enqueueing logic, delivering approximately **75x performance improvement** for message processing. It also introduces a trait refactoring that moves the `footprint()` method from the `EnqueueMessage` trait to a new `QueueFootprintQuery` trait.

## Performance Improvements

The PR demonstrates dramatic performance gains through batching XCMP message enqueueing:

- **Batched approach:** 134 microseconds to enqueue 1,000 3-byte messages
- **Individual approach:** 10,181 microseconds for the same task
- **Improvement ratio:** ~75x faster with batching

This optimization is critical for parachains like Moonbeam that handle high volumes of cross-chain transactions, particularly for:
- XCM asset transfers
- Cross-chain smart contract calls
- DMP (Downward Message Passing) from relay chain
- XCMP messages from sibling parachains

## Affected Components in Moonbeam

### 1. Runtime Dependencies (ALL RUNTIMES)

**Impact:** DIRECT - All three Moonbeam runtimes depend on the affected pallets

**Affected Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/Cargo.toml` (line 157)
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/Cargo.toml`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/Cargo.toml`

**Dependencies Updated:**
```toml
cumulus-pallet-xcmp-queue = { workspace = true }  # MAJOR bump
pallet-message-queue = { workspace = true }       # MINOR bump
frame-support = { workspace = true }              # MAJOR bump
```

### 2. XcmpQueue Pallet Configuration

**Impact:** DIRECT - All runtimes configure cumulus-pallet-xcmp-queue

**Configuration Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/xcm_config.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/src/xcm_config.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/src/xcm_config.rs`

**Current Configuration (Moonbase example):**
```rust
impl cumulus_pallet_xcmp_queue::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type ChannelInfo = ParachainSystem;
    type VersionWrapper = PolkadotXcm;
    type XcmpQueue = TransformOrigin<MessageQueue, AggregateMessageOrigin, ParaId, ParaIdToSibling>;
    type MaxInboundSuspended = sp_core::ConstU32<1_000>;
    type ControllerOrigin = EnsureRoot<AccountId>;
    type ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;
    type WeightInfo = moonbase_weights::cumulus_pallet_xcmp_queue::WeightInfo<Runtime>;
    type PriceForSiblingDelivery = polkadot_runtime_common::xcm_sender::NoPriceForMessageDelivery<
        cumulus_primitives_core::ParaId,
    >;
    type MaxActiveOutboundChannels = ConstU32<128>;
    type MaxPageSize = MessageQueueHeapSize;
}
```

**Benefit:** The batching optimization will automatically improve performance for all XCMP message processing without requiring configuration changes.

### 3. MessageQueue Pallet Configuration

**Impact:** DIRECT - Used for processing inbound XCMP and DMP messages

**Configuration Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/xcm_config.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/src/xcm_config.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/src/xcm_config.rs`

**Current Configuration (Moonbase example):**
```rust
impl pallet_message_queue::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    #[cfg(not(feature = "runtime-benchmarks"))]
    type MessageProcessor = pallet_ethereum_xcm::MessageProcessorWrapper<
        xcm_builder::ProcessXcmMessage<AggregateMessageOrigin, XcmExecutor, RuntimeCall>,
    >;
    type Size = u32;
    type HeapSize = MessageQueueHeapSize;
    type MaxStale = MessageQueueMaxStale;
    type ServiceWeight = MessageQueueServiceWeight;
    type QueueChangeHandler = NarrowOriginToSibling<XcmpQueue>;
    type QueuePausedQuery = EmergencyParaXcm;
    type WeightInfo = moonbase_weights::pallet_message_queue::WeightInfo<Runtime>;
    type IdleMaxServiceWeight = MessageQueueServiceWeight;
}
```

**Benefit:** More efficient message enqueueing will reduce database operations and improve overall XCM message throughput.

### 4. ParachainSystem Configuration (DMP Integration)

**Impact:** DIRECT - DMP queue uses MessageQueue for enqueuing

**Configuration File:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/lib.rs` (line 760)

**Current Configuration:**
```rust
impl cumulus_pallet_parachain_system::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnSystemEvent = ();
    type SelfParaId = ParachainInfo;
    type ReservedDmpWeight = ReservedDmpWeight;
    type OutboundXcmpMessageSource = XcmpQueue;
    type XcmpMessageHandler = XcmpQueue;
    type ReservedXcmpWeight = ReservedXcmpWeight;
    type CheckAssociatedRelayNumber = EmergencyParaXcm;
    type ConsensusHook = ConsensusHook;
    type DmpQueue = frame_support::traits::EnqueueWithOrigin<MessageQueue, RelayOrigin>; // ‚Üê Uses MessageQueue
    type WeightInfo = moonbase_weights::cumulus_pallet_parachain_system::WeightInfo<Runtime>;
    type SelectCore = cumulus_pallet_parachain_system::DefaultCoreSelector<Runtime>;
}
```

**Benefit:** Downward messages from the relay chain (Polkadot/Kusama/Westend) will benefit from the batching optimization.

### 5. Bridge Implementation (Trait Usage)

**Impact:** MEDIUM - Uses `EnqueueMessage` trait and `footprint()` method

**Affected File:** `/Users/manuelmauro/Workspace/moonbeam/runtime/common/src/bridge.rs`

**Current Usage:**
```rust
// Line 72: LocalBlobDispatcher uses EnqueueMessage trait
impl<
    MQ: EnqueueMessage<AggregateMessageOrigin>,
    OurPlace: Get<InteriorLocation>,
    OurPlaceBridgeInstance: Get<Option<InteriorLocation>>,
> DispatchBlob for LocalBlobDispatcher<MQ, OurPlace, OurPlaceBridgeInstance>

// Line 128: CongestionManager uses footprint() method
impl<Runtime: pallet_message_queue::Config> pallet_xcm_bridge::LocalXcmChannelManager
    for CongestionManager<Runtime>
where
    <Runtime as pallet_message_queue::Config>::MessageProcessor:
        ProcessMessage<Origin = AggregateMessageOrigin>,
{
    fn is_congested(_with: &Location) -> bool {
        let book_state =
            pallet_message_queue::Pallet::<Runtime>::footprint(AggregateMessageOrigin::Here);

        book_state.ready_pages >= MESSAGE_QUEUE_CONGESTION_THRESHOLD
    }
}
```

**Trait Changes Impact:**
The PR moves `footprint()` from the `EnqueueMessage` trait to a new `QueueFootprintQuery` trait. However, based on the code:
- The `footprint()` method is called directly on `pallet_message_queue::Pallet::<Runtime>` (line 128)
- This is a pallet method, not a trait method call
- **Conclusion:** No breaking changes expected for this usage pattern

**Note:** The trait `EnqueueMessage` is still used in the type bounds (line 72), but this should remain compatible as the trait signature for enqueueing messages is preserved.

### 6. Runtime Weights (Benchmarking)

**Impact:** MEDIUM - XcmpQueue weights need to be re-benchmarked

**Affected Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/weights/cumulus_pallet_xcmp_queue.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/src/weights/cumulus_pallet_xcmp_queue.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/src/weights/cumulus_pallet_xcmp_queue.rs`

**Current Benchmark Info (Moonbase):**
```rust
//! DATE: 2025-09-02, STEPS: `50`, REPEAT: `20`
//! HOSTNAME: `ip-10-0-0-198`, CPU: `Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz`
```

**Action Required:** Re-run benchmarks after upgrade to capture the performance improvements from batching. The new weight values will likely be significantly lower for message enqueueing operations.

**Benchmarking Command:**
```bash
./scripts/run-benches-for-runtime.sh moonbase release
```

### 7. XCM Integration Tests

**Impact:** LOW - Functional behavior remains the same

**Test Suites:** 65+ XCM-related test files in `/Users/manuelmauro/Workspace/moonbeam/test/suites/`

**Test Categories:**
- XCM v3/v4/v5 message transfers
- ERC20 XCM bridge operations
- Foreign assets XCM transfers
- XCM transactor precompile tests
- XCM autopause/congestion tests
- XCM payment API tests

**Expected Impact:** Tests should continue to pass as the functional behavior is preserved. The batching is an internal optimization that doesn't change the external API or message semantics.

**Tests with High XCM Volume (Most Beneficial):**
- `/Users/manuelmauro/Workspace/moonbeam/test/suites/dev/moonbase/test-xcm-v3/test-xcm-erc20-*.ts`
- `/Users/manuelmauro/Workspace/moonbeam/test/suites/smoke/test-relay-xcm-fees.ts`
- `/Users/manuelmauro/Workspace/moonbeam/test/suites/smoke/test-xcm-failures.ts`

### 8. XCM Mock Test Runtimes

**Impact:** LOW - Test infrastructure needs to stay in sync

**Affected Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/tests/xcm_mock/relay_chain.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/tests/xcm_mock/relay_chain.rs`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/tests/xcm_mock/relay_chain.rs`

These mock runtimes configure `pallet_message_queue::Config` for XCM simulation tests and should continue to work without changes.

## Breaking Changes

### API Changes

**Frame Support (MAJOR bump):**
- New trait: `QueueFootprintQuery` introduced
- The `footprint()` method moved from `EnqueueMessage` to `QueueFootprintQuery`
- The `EnqueueMessage` trait itself remains for message enqueueing

**Cumulus XcmpQueue (MAJOR bump):**
- Internal enqueueing logic now uses batching
- Config trait requirements remain the same
- Weight calculations updated to reflect batching performance

**Pallet Message Queue (MINOR bump):**
- Added support for batch enqueueing
- `footprint()` method still available on the pallet

### Migration Requirements

**For Moonbeam:**
1. **No code changes required** - The `footprint()` method is called on the pallet directly, not through a trait
2. **Weight updates required** - Re-run benchmarks to capture performance improvements
3. **Testing recommended** - Verify XCM message processing under load
4. **Cargo.lock update** - Dependency versions will be updated automatically

## Benefits for Moonbeam

### 1. Performance Improvements

**Direct Benefits:**
- **75x faster XCMP message enqueueing** - Critical for high-throughput scenarios
- **Reduced database operations** - Fewer writes per message batch
- **Lower block execution time** - More efficient message processing
- **Better resource utilization** - Reduced storage I/O overhead

**Use Cases That Benefit:**
- High-volume XCM asset transfers from exchanges or bridges
- Batch transfers via XCM (e.g., airdrops, multi-recipient transfers)
- Cross-chain DeFi operations (swaps, liquidity provision)
- Relay chain governance message processing

### 2. Scalability Improvements

**Network Capacity:**
- Higher XCMP message throughput per block
- Better handling of message bursts from sibling parachains
- Improved relay chain message (DMP) processing capacity

**Example Impact:**
- **Before:** 1,000 messages takes 10,181Œºs = 10.18ms of block time
- **After:** 1,000 messages takes 134Œºs = 0.134ms of block time
- **Block time saved:** ~10ms per 1,000 messages
- **Capacity increase:** Can process ~75x more messages in the same block time budget

### 3. Cost Efficiency

**Reduced Weight Consumption:**
- Lower weights for XCMP operations mean more transactions fit in a block
- Reduced weight means lower fees for XCM operations (if weight-based)
- Better block space utilization

**User Experience:**
- Faster cross-chain transfers
- More reliable message delivery during high congestion
- Improved responsiveness of XCM-based dApps

### 4. Congestion Management

**File:** `/Users/manuelmauro/Workspace/moonbeam/runtime/common/src/bridge.rs` (lines 116-142)

The `CongestionManager` implementation benefits from improved message processing:
- More messages can be processed before hitting congestion threshold
- Faster queue drainage during high load
- Better bridge reliability for cross-chain messaging

**Current Congestion Threshold:**
```rust
const MESSAGE_QUEUE_CONGESTION_THRESHOLD: u32 = 32; // 32 ready pages
```

With 75x faster processing, the system can handle burst traffic more effectively before triggering congestion controls.

## Risk Assessment

### Low Risk Areas

1. **Functional Compatibility:** The batching is an internal optimization; message semantics unchanged
2. **Trait Usage:** Moonbeam's `footprint()` usage is via pallet method, not affected by trait changes
3. **Configuration:** No changes required to existing pallet configurations

### Medium Risk Areas

1. **Weight Accuracy:** Weights need re-benchmarking to reflect new performance characteristics
   - **Mitigation:** Run full benchmark suite for all three runtimes
   - **Validation:** Compare old vs new weight values for significant changes

2. **Integration Testing:** XCM tests should verify batching works correctly under various scenarios
   - **Mitigation:** Run full XCM test suite (65+ tests)
   - **Focus:** High-volume message tests, congestion scenarios

3. **Cross-Chain Compatibility:** Ensure compatibility with other parachains still on older versions
   - **Mitigation:** The change is internal; protocol compatibility maintained
   - **Validation:** Test with sibling parachains on testnet (Westend)

### Testing Recommendations

**Pre-Upgrade Testing:**
```bash
# 1. Run Rust unit tests
cargo test -p moonbeam-runtime
cargo test -p moonriver-runtime
cargo test -p moonbase-runtime

# 2. Run XCM integration tests
cd test
pnpm moonwall test dev_moonbase  # Focus on XCM tests
pnpm moonwall test smoke_moonbase  # Smoke tests including XCM

# 3. Run benchmarks
./scripts/run-benches-for-runtime.sh moonbase release
./scripts/run-benches-for-runtime.sh moonriver release
./scripts/run-benches-for-runtime.sh moonbeam release
```

**Post-Upgrade Validation:**
1. Deploy to Moonbase Alpha (testnet) first
2. Monitor XCM message processing performance
3. Verify `MessageQueue` pallet metrics for improvements
4. Test high-volume XCM scenarios
5. Validate bridge functionality for cross-chain operations

## Recommended Actions

### Immediate (During Upgrade)

1. ‚úÖ **Update dependencies** - Already handled via workspace dependencies
2. ‚ö†Ô∏è **Re-run benchmarks** - Required to capture new performance characteristics
3. ‚úÖ **Run test suite** - Verify all XCM tests pass

### Post-Upgrade (After Deployment)

1. üìä **Monitor performance metrics:**
   - XCMP message processing latency
   - MessageQueue storage metrics
   - Block execution time for XCM-heavy blocks

2. üìà **Measure improvements:**
   - Compare message throughput before/after
   - Track congestion events frequency
   - Monitor user-facing XCM transfer times

3. üîç **Validate functionality:**
   - Cross-chain asset transfers (DeFi protocols)
   - Foreign asset operations
   - XCM transactor precompile operations
   - Bridge message processing

### Documentation Updates

1. Update runtime release notes with performance improvements
2. Document new benchmark results for developers
3. Update XCM integration guides if weight calculations changed
4. Communicate performance improvements to users and ecosystem projects

## Conclusion

**Overall Impact: POSITIVE - HIGH VALUE**

PR #8021 delivers a **75x performance improvement** for XCMP message processing with minimal breaking changes for Moonbeam. The optimization is particularly valuable for Moonbeam's role as an Ethereum-compatible parachain with high cross-chain activity.

**Key Takeaways:**
- ‚úÖ **No code changes required** - Moonbeam's usage patterns are compatible
- ‚ö†Ô∏è **Benchmarks must be re-run** - Critical to capture new weight values
- ‚úÖ **Major performance boost** - 75x faster message enqueueing
- ‚úÖ **Better scalability** - Higher message throughput capacity
- ‚úÖ **Improved UX** - Faster cross-chain operations for users
- ‚ö†Ô∏è **Testing required** - Comprehensive XCM test suite validation

**Priority Level: HIGH** - The performance improvements are significant, and the risks are manageable with proper benchmarking and testing.
