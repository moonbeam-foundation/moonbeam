# PR #8281 Impact Analysis: Common Implementation for XcmPaymentApi::query_weight_to_asset_fee

## Overview

**PR:** [#8281 - XcmPaymentApi::query_weight_to_asset_fee simple common impl](https://github.com/paritytech/polkadot-sdk/pull/8281)
**Audience:** Runtime Dev
**Impact Level:** NONE - Moonbeam has its own implementation
**Status:** Merged on May 6, 2025

## Summary

This PR adds a common helper implementation of `XcmPaymentApi::query_weight_to_asset_fee` to `pallet-xcm`, providing a reusable solution for runtime builders who need to implement XCM fee queries without writing custom logic. This is a simple workaround alternative to more complex refactoring approaches.

## What Changed

### The Problem Being Solved
Runtime builders implementing the `XcmPaymentApi` need to provide a `query_weight_to_asset_fee` function that calculates how much of a given asset is needed to pay for a given weight. Previously, each chain had to implement this logic themselves.

### The Solution Provided
PR #8281 adds a common implementation in `pallet-xcm` that uses an elegant workaround:

1. **Hypothetical Payment Approach**: The implementation passes `u128::MAX / 2` (2^127) as a hypothetical payment to the configured `WeightTrader`
2. **Fee Calculation**: By computing the difference between the hypothetical payment and what the trader returns, it determines the actual cost
3. **Transaction Scope**: The operation is transaction-scoped, preventing any actual state changes or issuance inflation
4. **Safety**: The high value (2^127) is mathematically safe - even currencies with 18 decimal places and trillions in total issuance remain far below overflow thresholds

### Affected Crates
- `pallet-xcm` (patch bump)
- Various parachain runtime crates (minor bumps)

## Impact on Moonbeam

### Current State: Custom Implementation

**Moonbeam already has a complete custom implementation and does NOT need the common implementation.**

#### Evidence 1: Custom XCM Weight Trader Pallet

Moonbeam maintains a custom pallet specifically for this purpose:

**File:** `/Users/manuelmauro/Workspace/moonbeam/pallets/xcm-weight-trader/src/lib.rs`

```rust
impl<T: Config> Pallet<T> {
    pub fn query_weight_to_asset_fee(
        weight: Weight,
        asset: VersionedAssetId,
    ) -> Result<u128, XcmPaymentApiError> {
        if let VersionedAssetId::V5(XcmAssetId(asset_location)) = asset
            .into_version(xcm::latest::VERSION)
            .map_err(|_| XcmPaymentApiError::VersionedConversionFailed)?
        {
            Trader::<T>::compute_amount_to_charge(&weight, &asset_location).map_err(|e| match e
            {
                XcmError::AssetNotFound => XcmPaymentApiError::AssetNotFound,
                _ => XcmPaymentApiError::WeightNotComputable,
            })
        } else {
            Err(XcmPaymentApiError::UnhandledXcmVersion)
        }
    }
}
```

This implementation:
- Converts the versioned asset to v5
- Calls `Trader::<T>::compute_amount_to_charge()` for fee calculation
- Handles both native and foreign assets through relative pricing

#### Evidence 2: Custom Trader Implementation

**File:** `/Users/manuelmauro/Workspace/moonbeam/pallets/xcm-weight-trader/src/lib.rs` (lines 355-383)

```rust
pub struct Trader<T: crate::Config>(Weight, Option<Asset>, core::marker::PhantomData<T>);

impl<T: crate::Config> Trader<T> {
    fn compute_amount_to_charge(
        weight: &Weight,
        asset_location: &Location,
    ) -> Result<u128, XcmError> {
        if *asset_location == <T as crate::Config>::NativeLocation::get() {
            // Native asset: use WeightToFee directly
            <T as crate::Config>::WeightToFee::weight_to_fee(&weight)
                .try_into()
                .map_err(|_| XcmError::Overflow)
        } else if let Some(relative_price) = Pallet::<T>::get_asset_relative_price(asset_location) {
            if relative_price == 0u128 {
                Ok(0u128)
            } else {
                // Foreign asset: apply relative price conversion
                let native_amount: u128 = <T as crate::Config>::WeightToFee::weight_to_fee(&weight)
                    .try_into()
                    .map_err(|_| XcmError::Overflow)?;
                Ok(native_amount
                    .checked_mul(10u128.pow(RELATIVE_PRICE_DECIMALS))
                    .ok_or(XcmError::Overflow)?
                    .checked_div(relative_price)
                    .ok_or(XcmError::Overflow)?)
            }
        } else {
            Err(XcmError::AssetNotFound)
        }
    }
}

impl<T: crate::Config> WeightTrader for Trader<T> {
    // ... WeightTrader trait implementation
}
```

#### Evidence 3: Runtime API Integration

**File:** `/Users/manuelmauro/Workspace/moonbeam/runtime/common/src/apis.rs` (lines 735-756)

All three Moonbeam runtimes (moonbase, moonriver, moonbeam) implement the `XcmPaymentApi` using the custom trader:

```rust
impl xcm_runtime_apis::fees::XcmPaymentApi<Block> for Runtime {
    fn query_acceptable_payment_assets(
        xcm_version: xcm::Version
    ) -> Result<Vec<VersionedAssetId>, XcmPaymentApiError> {
        XcmWeightTrader::query_acceptable_payment_assets(xcm_version)
    }

    fn query_weight_to_asset_fee(
        weight: Weight, asset: VersionedAssetId
    ) -> Result<u128, XcmPaymentApiError> {
        XcmWeightTrader::query_weight_to_asset_fee(weight, asset)
    }

    fn query_xcm_weight(message: VersionedXcm<()>) -> Result<Weight, XcmPaymentApiError> {
        PolkadotXcm::query_xcm_weight(message)
    }

    fn query_delivery_fees(
        destination: VersionedLocation, message: VersionedXcm<()>
    ) -> Result<VersionedAssets, XcmPaymentApiError> {
        PolkadotXcm::query_delivery_fees(destination, message)
    }
}
```

#### Evidence 4: XcmExecutor Configuration

**Files:**
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/xcm_config.rs:279`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/src/xcm_config.rs:273`
- `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/src/xcm_config.rs:265`

All three runtimes configure their XcmExecutor to use the custom Trader:

```rust
impl xcm_executor::Config for XcmExecutorConfig {
    type Weigher = XcmWeigher;
    // As trader we use the XcmWeightTrader pallet.
    // For each foreign asset, the fee is computed based on its relative price (also
    // stored in the XcmWeightTrader pallet) against the native asset.
    // For the native asset fee is computed using WeightToFee implementation.
    type Trader = pallet_xcm_weight_trader::Trader<Runtime>;
    type ResponseHandler = PolkadotXcm;
    type SubscriptionService = PolkadotXcm;
    // ... additional configuration
}
```

### Comparison: Moonbeam's Implementation vs PR #8281's Common Implementation

| Aspect | Moonbeam's Custom Implementation | PR #8281 Common Implementation |
|--------|----------------------------------|-------------------------------|
| **Location** | `pallet-xcm-weight-trader` (custom pallet) | `pallet-xcm` (common helper) |
| **Approach** | Direct calculation via `compute_amount_to_charge` | Workaround using hypothetical payment to WeightTrader |
| **Native Asset** | Direct `WeightToFee` conversion | Indirect via WeightTrader |
| **Foreign Assets** | Relative price lookup + conversion | Via WeightTrader with hypothetical payment |
| **Storage** | `SupportedAssets<T>` map with (enabled, price) | Uses WeightTrader's internal logic |
| **Flexibility** | Governable asset enable/disable + price updates | Depends on WeightTrader configuration |
| **Control** | Full governance control via extrinsics | Limited to WeightTrader configuration |

### Why Moonbeam's Custom Implementation is Superior

1. **Governance Control**: Moonbeam can dynamically add, edit, pause, resume, and remove supported assets through governance extrinsics
2. **Transparency**: Asset prices are stored on-chain and queryable
3. **Optimized**: Direct calculation without workaround overhead
4. **Battle-Tested**: The custom implementation has been in production across all Moonbeam networks
5. **Feature-Rich**: Includes asset filtering, pause/resume functionality, and configurable fee accounts

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Moonbeam Runtime                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Runtime API: XcmPaymentApi                                  │
│  ├── query_acceptable_payment_assets()                       │
│  │   └──> XcmWeightTrader::query_acceptable_payment_assets() │
│  │                                                            │
│  ├── query_weight_to_asset_fee()                             │
│  │   └──> XcmWeightTrader::query_weight_to_asset_fee()      │
│  │       └──> Trader::compute_amount_to_charge()             │
│  │           ├── Native Asset: WeightToFee                   │
│  │           └── Foreign Asset: Relative Price Lookup        │
│  │                                                            │
│  └── query_delivery_fees()                                   │
│      └──> PolkadotXcm::query_delivery_fees()                │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  XcmExecutor Config                                          │
│  └── type Trader = pallet_xcm_weight_trader::Trader<Runtime>│
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  Custom Pallet: pallet-xcm-weight-trader                     │
│  ├── Storage: SupportedAssets<Location, (bool, u128)>       │
│  ├── Extrinsics:                                             │
│  │   ├── add_asset(location, relative_price)                │
│  │   ├── edit_asset(location, relative_price)               │
│  │   ├── pause_asset(location)                              │
│  │   ├── resume_asset(location)                             │
│  │   └── remove_asset(location)                             │
│  └── Trader Implementation (WeightTrader trait)              │
└─────────────────────────────────────────────────────────────┘
```

## Assessment

### Immediate Impact: NONE

- **No Code Changes Required**: Moonbeam's custom implementation is completely independent
- **No Breaking Changes**: The PR provides an optional common implementation; existing implementations continue to work
- **No Dependencies Affected**: The change is in `pallet-xcm` but doesn't modify any trait definitions or existing functionality
- **No Migration Needed**: This is purely additive functionality for chains that don't have their own implementation

### Future Consideration: NOT RECOMMENDED

While the common implementation is available, **Moonbeam should continue using its custom implementation** for these reasons:

1. **Feature Superiority**: The custom pallet provides governance controls not available in the common implementation
2. **Price Management**: On-chain storage of asset prices with governable updates
3. **Asset Management**: Dynamic enable/disable of assets without runtime upgrades
4. **Production Proven**: The implementation has been successfully running across all Moonbeam networks
5. **No Performance Benefit**: The common implementation's workaround doesn't offer performance advantages over direct calculation

### Who Benefits from PR #8281?

This PR is valuable for:
- **New parachains** that don't have a custom WeightTrader and want quick XcmPaymentApi integration
- **Chains with simple fee requirements** that don't need dynamic asset management
- **Development/test chains** that want minimal configuration
- **Chains using standard WeightTrader implementations** from xcm-builder

## Related PRs

- **PR #7960**: Introduced view functions (Moonbeam uses traditional runtime APIs instead)
- **PR #8038**: XCM weight trader refactoring (related to WeightTrader implementations)

## Technical Details

### PR #8281 Implementation Approach

The common implementation in `pallet-xcm` works as follows:

1. Receives a weight and an asset to query
2. Creates a hypothetical payment of `u128::MAX / 2` in the specified asset
3. Passes this to the configured `WeightTrader` via `buy_weight()`
4. Calculates actual cost as: `hypothetical_payment - refund`
5. Returns the calculated fee

### Moonbeam's Implementation Approach

1. Receives a weight and an asset to query
2. Converts asset to v5 format
3. Checks if asset is native or foreign
4. For native: applies `WeightToFee` directly
5. For foreign: looks up relative price and applies conversion
6. Returns the calculated fee

## Recommendations

### Short Term (Current Release)
**No Action Required** - Continue using the existing custom implementation

### Long Term
**Maintain Custom Implementation** - The custom pallet provides superior functionality and governance control

### Code Locations (For Reference)

**Custom Implementation:**
- Pallet: `/Users/manuelmauro/Workspace/moonbeam/pallets/xcm-weight-trader/src/lib.rs`
- Runtime Integration: `/Users/manuelmauro/Workspace/moonbeam/runtime/common/src/apis.rs`
- Config (Moonbase): `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbase/src/xcm_config.rs`
- Config (Moonriver): `/Users/manuelmauro/Workspace/moonbeam/runtime/moonriver/src/xcm_config.rs`
- Config (Moonbeam): `/Users/manuelmauro/Workspace/moonbeam/runtime/moonbeam/src/xcm_config.rs`

**Tests:**
- Unit tests: `/Users/manuelmauro/Workspace/moonbeam/pallets/xcm-weight-trader/src/tests.rs`
- Integration tests: Various XCM test files in runtime test directories

## Conclusion

**Status:** No impact, no action required
**Risk Level:** None
**Priority:** Informational only

PR #8281 provides a useful common implementation for chains that need basic XcmPaymentApi functionality. However, Moonbeam's custom `pallet-xcm-weight-trader` offers significantly more features and control, making it the better choice for Moonbeam's production needs. The custom implementation should be maintained and preferred over the new common implementation.

This PR demonstrates the Polkadot SDK's flexibility in supporting both custom implementations (like Moonbeam's) and common utilities (like the new pallet-xcm helper) for different chain requirements.
