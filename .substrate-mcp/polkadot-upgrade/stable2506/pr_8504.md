# PR #8504 Analysis: Fix Generated Address in Substrate RPC Runtime Call

## Overview

**PR Number:** #8504
**Title:** Fix generated address returned by Substrate RPC runtime call
**Author:** castillax
**Status:** Merged (May 21, 2025) → **Reverted** → Superseded by PR #8662
**GitHub:** https://github.com/paritytech/polkadot-sdk/pull/8504
**Audience:** Runtime Dev

## Problem Statement

When dry-running a contract deployment through the runtime API, the returned contract address did not match the actual address that would be created when the transaction was submitted. This inconsistency caused issues for users who relied on dry-run results to predict deployment addresses.

### Root Cause

The address derivation logic in `pallet-revive` (`exec.rs`) used CREATE1-style address generation:

```rust
address::create1(
    &deployer,
    if origin_is_caller {
        account_nonce.saturating_sub(1u32.into()).saturated_into()
    } else {
        account_nonce.saturated_into()
    },
)
```

The code correctly subtracted 1 from the nonce during transaction execution (because the nonce is incremented pre-dispatch), but failed to account for whether this was a real transaction or a dry-run through RPC. In dry-runs, the nonce is never incremented, so the subtraction was incorrect.

### Impact

- **Before Fix:**
  - Dry-run returns address with nonce N
  - Actual transaction creates contract at address with nonce N-1
  - Result: Address mismatch between simulation and execution

- **After Fix:**
  - Both dry-run and transaction use the same address derivation
  - Consistent contract addresses regardless of execution context

## Solution Implemented

The fix introduced execution context awareness by checking both the caller condition and execution context:

```rust
address::create1(
    &deployer,
    if origin_is_caller && matches!(exec_context, ExecContext::Transaction) {
        account_nonce.saturating_sub(1u32.into()).saturated_into()
    } else {
        account_nonce.saturated_into()
    },
)
```

A `NonceAlreadyIncremented` enum was added to distinguish execution contexts, ensuring nonce subtraction only occurs during actual transaction execution.

## Changes Made

### Modified Files
- `substrate/frame/revive/src/exec.rs` - Core address derivation logic
- `substrate/frame/revive/src/call_builder.rs` - Context passing
- Runtime implementations - Propagating execution context

### Tests Added
- `nonce_not_incremented_in_dry_run()` - Verifies correct nonce handling in different execution contexts

## Affected Crates

| Crate | Bump | Impact |
|-------|------|--------|
| `pallet-revive` | major | Core fix location |
| `asset-hub-westend-runtime` | patch | Runtime update |

## Important Note: PR Reverted

**This PR was subsequently reverted (commit 193b5e3) and superseded by PR #8662.**

The revert suggests that while this approach fixed the immediate issue, a different solution (likely the `prepare_dry_run` approach in #8662) was deemed more appropriate or cleaner architecturally.

## Moonbeam Impact Assessment

### Relevance: LOW

**Moonbeam does not use `pallet-revive`**. This pallet is part of Polkadot SDK's new contract system and is not currently integrated into Moonbeam's runtime.

Moonbeam uses:
- `pallet-evm` for Ethereum compatibility
- `pallet-ethereum` for Ethereum transaction handling
- Custom precompiles for Substrate↔EVM interop

### Action Required: NONE

- No code changes needed
- No testing required
- No migration necessary

### Monitoring Recommendation

If Moonbeam ever considers integrating `pallet-revive` in the future:
1. Follow PR #8662 (the superseding fix) instead of this one
2. Ensure any address derivation logic properly handles execution contexts
3. Verify contract deployment addresses match between RPC queries and actual transactions

## References

- **Issue:** https://github.com/paritytech/contract-issues/issues/37
- **Related PR:** #8662 (superseding fix)
- **Revert Commit:** 193b5e3

## Conclusion

This PR identified and initially fixed a critical bug in contract address derivation for `pallet-revive`, but was later reverted in favor of a better solution. Since Moonbeam doesn't use `pallet-revive`, this change has no impact on the Moonbeam codebase and requires no action.
