// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.0;

/// The interface through which solidity contracts will interact with Parachain Staking
/// We follow this same interface including four-byte function selectors, in the precompile that
/// wraps the pallet
interface ParachainStaking {
    // First some simple accessors

    /// Check whether the specified address is currently a staking nominator
    function is_nominator(address nominator) external view returns (bool);

    /// Check whether the specified addess is currently a collator candidate
    function is_candidate(address collator) external view returns (bool);

    /// Check whether the specifies address is currently a part of the active set
    function is_selected_candidate(address collator)
        external
        view
        returns (bool);

    /// Total points awarded to all collators in a particular round.
    function points(uint256 round) external view returns (uint256);

    /// Get the minimum nomination amount
    function min_nomination() external view returns (uint256);

    // Now the dispatchables

    /// Join the set of collator candidates
    function join_candidates(uint256 amount, uint256 candidateCount) external;

    /// Request to leave the set of candidates. If successful, the account is immediately
    /// removed from the candidate pool to prevent selection as a collator, but unbonding is
    /// executed with a delay of `BondDuration` rounds.
    function leave_candidates(uint256 amount, uint256 candidateCount) external;

    /// Temporarily leave the set of collator candidates without unbonding
    function go_offline() external;

    /// Rejoin the set of collator candidates if previously had called `go_offline`
    function go_online() external;

    /// Bond more for collator candidates
    function candidate_bond_more(uint256 more) external;

    /// Bond less for collator candidates
    function candidate_bond_less(uint256 less) external;

    /// If caller is not a nominator, then join the set of nominators
    /// If caller is a nominator, then makes nomination to change their nomination state
    function nominate(
        address collator,
        uint256 amount,
        uint256 collatorNominationCount,
        uint256 nominatorNominationCount
    ) external;

    /// Leave the set of nominators and, by implication, revoke all ongoing nominations
    function leave_nominators(uint256 nominatorNominationCount) external;

    /// Revoke an existing nomination
    function revoke_nomination(address collator) external;

    /// Bond more for nominators with respect to a specific collator candidate
    function nominator_bond_more(address candidate, uint256 more) external;

    /// Bond less for nominators with respect to a specific nominator candidate
    function nominator_bond_less(address candidate, uint256 less) external;
}

// These are the selectors generated by remix following this advice
// https://ethereum.stackexchange.com/a/73405/9963
// Eventually we will probably want a better way of generating these and copying them to Rust
// {
// 	"289b6ba7": "candidate_bond_less(uint256)",
// 	"c57bd3a8": "candidate_bond_more(uint256)",
// 	"767e0450": "go_offline()",
// 	"d2f73ceb": "go_online()",
// 	"8545c833": "is_candidate(address)",
// 	"8f6d27c7": "is_selected_candidate(address)",
// 	"8e5080e7": "is_nominator(address)",
// 	"0a1bff60": "join_candidates(uint256,uint256)",
// 	"72b02a31": "leave_candidates(uint256)",
// 	"b71d2153": "leave_nominators(uint256)",
// 	"c9f593b2": "min_nomination()",
// 	"49df6eb3": "nominate(address,uint256,uint256,uint256)",
// 	"f6a52569": "nominator_bond_less(address,uint256)",
// 	"971d44c8": "nominator_bond_more(address,uint256)",
// 	"4b65c34b": "revoke_nomination(address)"
// 	"9799b4e7": "points(uint256)"
// }
