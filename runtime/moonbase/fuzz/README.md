# Moonbeam fuzzer handover

## Introducing Ziggy

[Ziggy](https://github.com/srlabs/ziggy) is a fuzzer management tool that can be used for any Rust project.

It starts AFL++ and honggfuzz at the same time.

An easy [example](https://github.com/srlabs/ziggy/tree/main/examples/url) is a fuzzer for a URL parsing library:

```rust
fn main() {
    /// "ziggy::fuzz!"" is the macro exported by ziggy that give you
    /// access to the data generared by the fuzzers
    ziggy::fuzz!(|data: &[u8]| {
        if let Ok(s) = std::str::from_utf8(data) {
        
            /// "coverage" is a configuration that gets set while the
            /// coverage is being run; usually we want do print
            /// more data while generating the coverage
            #[cfg(coverage)]
            println!("Generating coverage ...");
            
            #[allow(unused_variables)]
            if let Ok(parsed) = url::Url::parse(s) {
                /// the "fuzzing" configuration is being set while the fuzzer
                /// is running
                #[cfg(not(fuzzing))]
                println!("{parsed}");
            }
        }
    });
}
```

## Fuzzing Moonbase runtime

The fuzz harness is available in [sr-moonbeam](https://github.com/moonbeam-foundation/sr-moonbeam/fuzz) repo.

The commit hash that was used for the Moonbeam project is `fa45df8b128a82f6064b42d4498abc37929a0f4b`.

### Steps to start fuzzing

1. Install ziggy and its dependencies: `cargo install --force ziggy cargo-afl honggfuzz grcov`
2. Clone moonbeam
3. `cd runtime/moonbase`
4. Add the `fuzz` folder from the `sr-moonbeam` repo into the `moonbase` runtime dir. Your tree will look like this:

    ```
    └── moonbase
        ├── build.rs
        ├── Cargo.toml
        ├── fuzz
        │   ├── cargo_home
        │   ├── Cargo.toml
        │   ├── env.sh
        │   ├── magic.dict
        │   ├── output
        │   └── src
        │       └── main.rs
        ├── src
        └── tests
    ```
6. Add the `fuzz` project as a member in your workspace: edit `Cargo.toml` from the root of Moonbeam and add `runtime/moonbase/fuzz` in the `members` list
7. Activate the environment: `. env.sh`
8. Build the fuzzer: `cargo ziggy build`
9. Start fuzzing: `cargo ziggy fuzz -j 20 -x magic.dict -t 10`

### Steps to generate the coverage

1. Run `cargo ziggy cover -s <the_root_of_your_moonbeam_folder>`
2. `cd output/moonbase-runtime-fuzz/coverage/`
3. `python3 -m http.server 8082`
4. Open you browser and navigate to [http://localhost:8082](http://localhost:8082)

### Steps to analyze the crashes

If there is a crash, it is beneficial to be fixed, such as the fuzzing process can continue more efficient.

1. List the folders with all the crashes: `ls -lht output/moonbase-runtime-fuzz/crashes`
2. Usually the folder with the latest timestamp contains the newest crash. You can also run the crashes from the other folders to make sure everything is ok
3. Run the crashes: `cargo ziggy run -i output/moonbase-runtime-fuzz/crashes/16xyz`
4. Fix the crash in your code, run the crashes again to validate your implementation
5. Restart the fuzzer

**Note: if the crash happens in a dependency, you would most probably have to delete the .so file for the dependency from the `target` directory, to force its recompilation**

### Ways to improve the coverage

#### Using GenesisConfig

Some pallets might have a `struct GenesisConfig` defined that could be used to setup required values for the blockchain to run. If that is the case, you can add it in the harness of the fuzzer. Search for the `let genesis_storage: Storage` definition and add your `GenesisConfig` call.

#### Changing the Origin check

Some extrinsic accept a call from specific origins, which can be represented by a collective or a custom origin type defined in the runtime. You have to fix this, either by chainging the definition of the origin and making it `EnsureSigned` in the runtime, or by replacing it with `ensure_signed` in the extrinsic itself. You could also call the `GenesisConfig` for the collective pallet and add your accounts in there.

#### Modifying an existing seed

The idea here is to start from a seed that was already generated by the fuzzer and is close to your goal seed, and modify it with the values that you want, in order to improve the coverage.

When you run the `cargo ziggy cover` command, the output prints the calls that are being done in every seed file. You can save this output to a `.txt` file and search in the file for a seed that creates a call to an extrinsic that you want to improve.

For example, you might want to improve the coverage for the extrinsic `cook_pasta`, but one of the parameters of the extrinsic has to be number `29923`. You can get the hex representation of a seed that already exists for the `cook_pasta` by using `xxd -c 30000 -p output/moonbase-runtime-fuzz/corpus/some_seed_file.cov`. Save the hex encoding in a text file (i.e. `cook_pasta.txt`).

Open the `cook_pasta.txt` with a text editor and edit the scale codec values based on the values that you want to have in yuor extrinsic.

Convert it to binary and test: `xxd -r -p cook_pasta.txt > cook_pasta.cov; ./target/runner/debug/moonbase-runtime-fuzz cook_pasta.cov`.

Once your seed is good, you can save it to a folder (consider creating a `custom_seeds` folder) and add it to your currently running fuzzer. Make sure that the fuzzer is running and then you can use the `add-seeds` functionality of `ziggy`: `cargo ziggy add-seeds -i custom_seeds`.

### Understanding the format of the seeds

One seed can include multiple extrinsic calls. The separator between extrinsic calls is `********`, which is represented as `2a2a2a2a2a2a2a2a` in hex.

The extrinsic cal is incoded as follow:

```rust
let lapse: u32 = u32::from_ne_bytes(data[0..4].try_into().unwrap());
let origin: usize = u16::from_ne_bytes(data[4..6].try_into().unwrap()) as usize;
let real_origin: H160 = H160::from_slice(&data[8..28]);
let is_precompile: bool = data.len() >= 48 && precompile_addresses.contains(&H160::from_slice(&data[28..48]));
let mut encoded_extrinsic: &[u8] = &data[6..];
```

- the first 4 bytes represent the lapse of the current call from the last one; if the value is 0, the extrinsic will be in the same block as the previous one
- the next 2 bytes represent the origin account which will do the call
- all the other bytes are the scale encoded extrinsic
- if the call is for a precompile the bytes 8..28 are the origin who does the call, and bytes 28..48 the address of the precompile

