import "@moonbeam-network/api-augment";
import { describeSuite, expect, beforeAll, customDevRpcRequest } from "@moonwall/cli";
import type { ApiPromise } from "@polkadot/api";
import { parseEther } from "ethers";
import {
  expectOk,
  registerOldForeignAsset,
  PARA_1000_SOURCE_LOCATION,
  mockOldAssetBalance,
} from "../../helpers";
import { ALITH_ADDRESS, alith } from "@moonwall/util";
import type { u128 } from "@polkadot/types-codec";
import { randomAsHex } from "@polkadot/util-crypto";

describeSuite({
  id: "T23",
  title: "Multi traces per substrate transaction",
  foundationMethods: "dev",
  testCases: ({ context, it }) => {
    let api: ApiPromise;
    let assetId: u128;

    beforeAll(async () => {
      api = context.polkadotJs();

      // Register foreign asset using helper
      const { registeredAssetId } = await registerOldForeignAsset(
        context,
        PARA_1000_SOURCE_LOCATION,
        {
          name: "Foreign Asset",
          symbol: "FA",
          decimals: 18n,
          isFrozen: false,
        }
      );

      assetId = context.polkadotJs().createType("u128", registeredAssetId);

      // Define test accounts and their balances
      const accounts = [{ address: ALITH_ADDRESS, balance: "1000000" }];

      const totalSupply = accounts
        .reduce((sum, account) => sum + Number.parseFloat(account.balance), 0)
        .toString();

      // Create asset details
      const assetDetails = context.polkadotJs().createType("PalletAssetsAssetDetails", {
        supply: parseEther(totalSupply),
        owner: ALITH_ADDRESS,
        deposit: 1,
        isSufficient: false,
        minBalance: 1,
        isFrozen: false,
        sufficients: 0,
        approvals: 0,
      });

      // Create balances for all test accounts
      for (const { address, balance } of accounts) {
        const assetBalance = context.polkadotJs().createType("PalletAssetsAssetAccount", {
          balance: parseEther(balance),
          isFrozen: false,
          reason: "Consumer",
          extra: null,
        });

        await mockOldAssetBalance(context, assetBalance, assetDetails, alith, assetId, address);
      }
      await context.createBlock([]);

      for (let i = 0; i < 200; i++) {
        const addr = randomAsHex(20);
        await expectOk(
          context.createBlock(api.tx.assets.approveTransfer(assetId, addr, parseEther("5")), {
            signer: alith,
            allowFailures: false,
          })
        );
      }
    });

    it({
      id: "T01",
      title:
        "Verify tracer is able to handle multiple traces generated by a single substrate transaction",
      test: async function () {
        // Approve migration with sudo
        await expectOk(
          context.createBlock(
            api.tx.sudo.sudo(api.tx.moonbeamLazyMigrations.approveAssetsToMigrate([assetId]))
          )
        );

        await expectOk(
          context.createBlock(api.tx.moonbeamLazyMigrations.startForeignAssetsMigration(assetId))
        );

        // Migrate approvals
        await expectOk(
          context.createBlock(api.tx.moonbeamLazyMigrations.migrateForeignAssetApprovals(200))
        );

        const block = await context.viem().getBlock();

        for (const tx of block.transactions) {
          const result = await customDevRpcRequest("debug_traceTransaction", [
            tx,
            { tracer: "callTracer" },
          ]);
          expect(result).to.toMatchObject({
            from: "0xf24ff3a9cf04c71dbc94d0b566f7a27b94566cac",
            type: "CALL",
            to: "0xffffffffeaf696ccc21aee89bb8dfc506fb2ffc2",
            output: "0x0000000000000000000000000000000000000000000000000000000000000001",
            value: "0x0",
          });
        }
      },
    });
  },
});
