{
  "byteCode": "0x",
  "contract": {
    "abi": [
      {
        "inputs": [
          { "internalType": "address", "name": "have", "type": "address" },
          { "internalType": "address", "name": "want", "type": "address" }
        ],
        "name": "OnlyRandomnessPrecompileCanFulfill",
        "type": "error"
      },
      {
        "inputs": [
          { "internalType": "uint256", "name": "requestId", "type": "uint256" },
          {
            "internalType": "uint256[]",
            "name": "randomWords",
            "type": "uint256[]"
          }
        ],
        "name": "rawFulfillRandomWords",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ],
    "devdoc": {
      "details": "PURPOSEThe purpose of this contract is to make it easy for contracts to talk tothe Randomness Precompile. It ensures 2 things:1. The fulfillment came from the Randomness Precompile2. The consumer contract implements fulfillRandomWords. *****************************************************************************USAGECalling contracts must inherit from RandomnessConsumerCall one of the randomness request functions:1. requestLocalVRFRandomWords(refundAddress, fee, gasLimit, saltnumWords, delay),2. requestRelayBabeEpochRandomWords(refundAddress, fee, gasLimit, saltnumWords),see (Randomness.sol for a description of each function and their arguments).Once the request has been registered and the minimum delay is passed, therequest then can be executed (for 0 fee) by anyone. it will call yourcontract's fulfillRandomWords method.The randomness argument to fulfillRandomWords is a set of random wordsgenerated from your requestId.If your contract could have concurrent requests open, you can use therequestId returned from requestRandomWords to track which response is associatedwith which randomness request.See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,if your contract could have multiple requests in flight simultaneously.Colliding `requestId`s are cryptographically impossible as long as seedsdiffer. *****************************************************************************SECURITY CONSIDERATIONSA method with the ability to call your fulfillRandomness method directlycould spoof a VRF response with any random value, so it's critical thatit cannot be directly called by anything other than this base contract(specifically, by the RandomnessConsumer.rawFulfillRandomness method).For your users to trust that your contract's random behavior is freefrom malicious interference, it's best if you can write it so that allbehaviors implied by a VRF response are executed *during* yourfulfillRandomness method. If your contract must store the response (oranything derived from it) and use it later, you must ensure that anyuser-significant behavior which depends on that stored value cannot bemanipulated by a subsequent VRF request.Similarly, the collators have some influence over the order in whichVRF responses appear on the blockchain, so if your contract could havemultiple VRF requests in flight simultaneously, you must ensure thatthe order in which the VRF responses arrive cannot be used to manipulateyour contract's user-significant behavior.Since the output of the random words generated for*requestLocalVRFRandomWords* is dependant of the collator producing theblock at fulfillment, the collator could skip its block forcing thefulfillment to be executed by a different collator, and thereforegenerating a different VRF.However, such an attack would incur the cost of losing the block reward tothe collator.It is also possible for a collator to be able to predict some of thepossible outcome of the VRF if the delay between the request and thefulfillment is too short. It is for this reason that we allow to providea higher delaySince the output of the random words generated for*requestRelayBabeEpochRandomWords* is dependant of the relaychainvalidator producing the blocks during an epoch, it is possible forthe last validator of an epoch to choose between 2 possible VRFoutputs by skipping the production of a block.However, such an attack would incur the cost of losing the block reward tothe validatorIt is not possible for a parachain collator to predict nor influencethe output of the relaychain VRF, not to censor the fulfillment as long asthere is one honest collator.",
      "kind": "dev",
      "methods": {},
      "version": 1
    },
    "evm": {
      "assembly": "",
      "bytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "deployedBytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "immutableReferences": {},
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "gasEstimates": null,
      "legacyAssembly": null,
      "methodIdentifiers": {
        "rawFulfillRandomWords(uint256,uint256[])": "1fe543e3"
      }
    },
    "ewasm": { "wasm": "" },
    "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyRandomnessPrecompileCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"PURPOSEThe purpose of this contract is to make it easy for contracts to talk tothe Randomness Precompile. It ensures 2 things:1. The fulfillment came from the Randomness Precompile2. The consumer contract implements fulfillRandomWords. *****************************************************************************USAGECalling contracts must inherit from RandomnessConsumerCall one of the randomness request functions:1. requestLocalVRFRandomWords(refundAddress, fee, gasLimit, saltnumWords, delay),2. requestRelayBabeEpochRandomWords(refundAddress, fee, gasLimit, saltnumWords),see (Randomness.sol for a description of each function and their arguments).Once the request has been registered and the minimum delay is passed, therequest then can be executed (for 0 fee) by anyone. it will call yourcontract's fulfillRandomWords method.The randomness argument to fulfillRandomWords is a set of random wordsgenerated from your requestId.If your contract could have concurrent requests open, you can use therequestId returned from requestRandomWords to track which response is associatedwith which randomness request.See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,if your contract could have multiple requests in flight simultaneously.Colliding `requestId`s are cryptographically impossible as long as seedsdiffer. *****************************************************************************SECURITY CONSIDERATIONSA method with the ability to call your fulfillRandomness method directlycould spoof a VRF response with any random value, so it's critical thatit cannot be directly called by anything other than this base contract(specifically, by the RandomnessConsumer.rawFulfillRandomness method).For your users to trust that your contract's random behavior is freefrom malicious interference, it's best if you can write it so that allbehaviors implied by a VRF response are executed *during* yourfulfillRandomness method. If your contract must store the response (oranything derived from it) and use it later, you must ensure that anyuser-significant behavior which depends on that stored value cannot bemanipulated by a subsequent VRF request.Similarly, the collators have some influence over the order in whichVRF responses appear on the blockchain, so if your contract could havemultiple VRF requests in flight simultaneously, you must ensure thatthe order in which the VRF responses arrive cannot be used to manipulateyour contract's user-significant behavior.Since the output of the random words generated for*requestLocalVRFRandomWords* is dependant of the collator producing theblock at fulfillment, the collator could skip its block forcing thefulfillment to be executed by a different collator, and thereforegenerating a different VRF.However, such an attack would incur the cost of losing the block reward tothe collator.It is also possible for a collator to be able to predict some of thepossible outcome of the VRF if the delay between the request and thefulfillment is too short. It is for this reason that we allow to providea higher delaySince the output of the random words generated for*requestRelayBabeEpochRandomWords* is dependant of the relaychainvalidator producing the blocks during an epoch, it is possible forthe last validator of an epoch to choose between 2 possible VRFoutputs by skipping the production of a block.However, such an attack would incur the cost of losing the block reward tothe validatorIt is not possible for a parachain collator to predict nor influencethe output of the relaychain VRF, not to censor the fulfillment as long asthere is one honest collator.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"****************************************************************************Interface for contracts using VRF randomness *****************************************************************************\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"main.sol\":\"RandomnessConsumer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"main.sol\":{\"keccak256\":\"0xda1dd13eff362e64385a1f52452844539ec2ba2d16350adaa467822533aae8ca\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://0c93a2e46a53a5ed6f8b7fe4cfdc39c840857a2c57dd780c560d3bd9bf16e148\",\"dweb:/ipfs/QmWvAC7YqwGHi6SmgkFtyTeQTunXDCX1gvRPkUFoPXDjuW\"]}},\"version\":1}",
    "storageLayout": { "storage": [], "types": null },
    "userdoc": {
      "kind": "user",
      "methods": {},
      "notice": "****************************************************************************Interface for contracts using VRF randomness *****************************************************************************",
      "version": 1
    }
  },
  "sourceCode": "// Inspired by: https://raw.githubusercontent.com/smartcontractkit/chainlink/8e8a996fd882c0861bdc9824c1ca27c857c87d03/contracts/src/v0.8/VRFConsumerBaseV2.sol\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev The purpose of this contract is to make it easy for contracts to talk to\n * @dev the Randomness Precompile. It ensures 2 things:\n * @dev 1. The fulfillment came from the Randomness Precompile\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from RandomnessConsumer\n *\n * @dev Call one of the randomness request functions:\n * @dev 1. requestLocalVRFRandomWords(refundAddress, fee, gasLimit, salt\n * @dev numWords, delay),\n * @dev 2. requestRelayBabeEpochRandomWords(refundAddress, fee, gasLimit, salt\n * @dev numWords),\n * @dev see (Randomness.sol for a description of each function and their arguments).\n *\n * @dev Once the request has been registered and the minimum delay is passed, the\n * @dev request then can be executed (for 0 fee) by anyone. it will call your\n * @dev contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the RandomnessConsumer.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, the collators have some influence over the order in which\n * @dev VRF responses appear on the blockchain, so if your contract could have\n * @dev multiple VRF requests in flight simultaneously, you must ensure that\n * @dev the order in which the VRF responses arrive cannot be used to manipulate\n * @dev your contract's user-significant behavior.\n *\n * @dev Since the output of the random words generated for\n * @dev *requestLocalVRFRandomWords* is dependant of the collator producing the\n * @dev block at fulfillment, the collator could skip its block forcing the\n * @dev fulfillment to be executed by a different collator, and therefore\n * @dev generating a different VRF.\n * @dev However, such an attack would incur the cost of losing the block reward to\n * @dev the collator.\n * @dev It is also possible for a collator to be able to predict some of the\n * @dev possible outcome of the VRF if the delay between the request and the\n * @dev fulfillment is too short. It is for this reason that we allow to provide\n * @dev a higher delay\n *\n * @dev Since the output of the random words generated for\n * @dev *requestRelayBabeEpochRandomWords* is dependant of the relaychain\n * @dev validator producing the blocks during an epoch, it is possible for\n * @dev the last validator of an epoch to choose between 2 possible VRF\n * @dev outputs by skipping the production of a block.\n * @dev However, such an attack would incur the cost of losing the block reward to\n * @dev the validator\n * @dev It is not possible for a parachain collator to predict nor influence\n * @dev the output of the relaychain VRF, not to censor the fulfillment as long as\n * @dev there is one honest collator.\n */\nabstract contract RandomnessConsumer {\n    error OnlyRandomnessPrecompileCanFulfill(address have, address want);\n\n    /**\n     * @notice fulfillRandomness handles the VRF response. Your contract must\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n     * @notice principles to keep in mind when implementing your fulfillRandomness\n     * @notice method.\n     *\n     * @dev RandomnessConsumer expects its subcontracts to have a method with this\n     * @dev signature, and will call it once it has verified the proof\n     * @dev associated with the randomness. (It is triggered via a call to\n     * @dev rawFulfillRandomness, below.)\n     *\n     * @param requestId The Id initially returned by requestLocalVRFRandomWords or requestRelayBabeEpochRandomWords\n     * @param randomWords The VRF output expanded to the requested number of words\n     */\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)\n        internal\n        virtual;\n\n    // rawFulfillRandomness is called by Randomness Precompile when the executeFulfillement\n    // is called. rawFulfillRandomness then calls fulfillRandomness, after validating\n    // the origin of the call\n    function rawFulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) external {\n        if (msg.sender != RANDOMNESS_ADDRESS) {\n            revert OnlyRandomnessPrecompileCanFulfill(\n                msg.sender,\n                RANDOMNESS_ADDRESS\n            );\n        }\n        fulfillRandomWords(requestId, randomWords);\n    }\n}\n"
}
