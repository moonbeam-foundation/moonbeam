{
  "byteCode": "0x",
  "contract": {
    "abi": [
      {
        "inputs": [
          { "internalType": "bytes", "name": "contractCode", "type": "bytes" },
          {
            "internalType": "bytes",
            "name": "contractStorageKey",
            "type": "bytes"
          }
        ],
        "name": "autoUpgrade",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "proposalId",
        "outputs": [{ "internalType": "uint16", "name": "", "type": "uint16" }],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "rootTrackId",
        "outputs": [{ "internalType": "uint16", "name": "", "type": "uint16" }],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "setStorageCallIndex",
        "outputs": [{ "internalType": "bytes2", "name": "", "type": "bytes2" }],
        "stateMutability": "view",
        "type": "function"
      }
    ],
    "devdoc": { "kind": "dev", "methods": {}, "version": 1 },
    "evm": {
      "assembly": "",
      "bytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "deployedBytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "immutableReferences": {},
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "gasEstimates": null,
      "legacyAssembly": null,
      "methodIdentifiers": {
        "autoUpgrade(bytes,bytes)": "79688e99",
        "proposalId()": "2dfca445",
        "rootTrackId()": "6d72ffb6",
        "setStorageCallIndex()": "920e0c03"
      }
    },
    "ewasm": { "wasm": "" },
    "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"contractCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"contractStorageKey\",\"type\":\"bytes\"}],\"name\":\"autoUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootTrackId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStorageCallIndex\",\"outputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"autoUpgrade(bytes,bytes)\":{\"notice\":\"TODO Add check for deposit value\"},\"constructor\":{\"notice\":\"construct the smart contract with the track id to send the proposal to\"},\"proposalId()\":{\"notice\":\"The id of the track used for root execution\"},\"rootTrackId()\":{\"notice\":\"The id of the track used for root execution\"},\"setStorageCallIndex()\":{\"notice\":\"SetStorageCall index (pallet Index concatenated with call index, usually \\\"\\\\x00\\\\x04\\\")\"}},\"notice\":\"Smart contract to demonstrate how to use Referenda Precompile to self-upgrade\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"main.sol\":\"ReferendaAutoUpgradeDemo\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"main.sol\":{\"keccak256\":\"0x9c816acad392e46e90fabcda4b6b65aa1ecd5cd1e690d2f8ac464c12f4e96f29\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://84f3d3ad1b109b1571fa1592a7f8e01bf1956be02b3b1f8261b480732132a590\",\"dweb:/ipfs/QmQbQYQ6CTAeod2xNfD7merZyEF7bcf4ym6xYtRiKRq1by\"]},\"precompiles/preimage/Preimage.sol\":{\"keccak256\":\"0x8b0a12d239d2226ae5d5d79761b0e66c3aa9bdbe2fb41d512478bbd8b5d516ec\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://8405c679cdc5ecc4725e1869c620910ed303dfdab74a617af60e6b4c6df6ca3e\",\"dweb:/ipfs/QmPsXz13YLPKX2FjaLTZTW1cEBeVL1cKt4GoJewtiHjv2P\"]},\"precompiles/referenda/Referenda.sol\":{\"keccak256\":\"0x3f4ad640fb2fe333c9a24ae203847c3629e9edd7cb87f6722fff8de440c3f6da\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://454133320632006c8dead321ef116befb1d56489c9ac1fe83c937a9833647a0e\",\"dweb:/ipfs/Qmadr6k9LenduFNokz1tWsK4QqQ473ZjqMKuP3qJizFi4W\"]}},\"version\":1}",
    "storageLayout": {
      "storage": [
        {
          "astId": 7,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "rootTrackId",
          "offset": 0,
          "slot": "0",
          "type": "t_uint16"
        },
        {
          "astId": 10,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "setStorageCallIndex",
          "offset": 2,
          "slot": "0",
          "type": "t_bytes2"
        },
        {
          "astId": 13,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "proposalId",
          "offset": 4,
          "slot": "0",
          "type": "t_uint16"
        }
      ],
      "types": {
        "t_bytes2": {
          "encoding": "inplace",
          "label": "bytes2",
          "numberOfBytes": "2"
        },
        "t_uint16": {
          "encoding": "inplace",
          "label": "uint16",
          "numberOfBytes": "2"
        }
      }
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "autoUpgrade(bytes,bytes)": {
          "notice": "TODO Add check for deposit value"
        },
        "constructor": {
          "notice": "construct the smart contract with the track id to send the proposal to"
        },
        "proposalId()": {
          "notice": "The id of the track used for root execution"
        },
        "rootTrackId()": {
          "notice": "The id of the track used for root execution"
        },
        "setStorageCallIndex()": {
          "notice": "SetStorageCall index (pallet Index concatenated with call index, usually \"\\x00\\x04\")"
        }
      },
      "notice": "Smart contract to demonstrate how to use Referenda Precompile to self-upgrade",
      "version": 1
    }
  },
  "sourceCode": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.3;\n\nimport \"../../../precompiles/referenda/Referenda.sol\";\nimport \"../../../precompiles/preimage/Preimage.sol\";\n\n/// @notice Smart contract to demonstrate how to use Referenda Precompile to self-upgrade\nabstract contract ReferendaAutoUpgradeDemo {\n    /// @notice The id of the track used for root execution\n    uint16 public rootTrackId;\n\n    /// @notice SetStorageCall index (pallet Index concatenated with call index, usually \"\\x00\\x04\")\n    bytes2 public setStorageCallIndex;\n\n    /// @notice The id of the track used for root execution\n    uint16 public proposalId;\n\n    /// @notice construct the smart contract with the track id to send the proposal to\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex) {\n        setStorageCallIndex = pSetStorageCallIndex;\n        uint16[] memory trackIds = REFERENDA_CONTRACT.trackIds();\n\n        // This is obviously NOT THE RIGHT WAY to find/store the track id.\n        // The track id should be passed as an argument of the constructor instead of the\n        // track name.\n        // In this demo, it is using the track name to show how to loop through the trackIds.\n        for (uint256 i = 0; i < trackIds.length; i++) {\n            Referenda.TrackInfo memory info = REFERENDA_CONTRACT.trackInfo(\n                trackIds[i]\n            );\n            if (\n                keccak256(abi.encodePacked((info.name))) ==\n                keccak256(abi.encodePacked((trackName))) // Compare the 2 strings\n            ) {\n                rootTrackId = trackIds[i];\n                return;\n            }\n        }\n\n        revert(\"Couldn't find track\");\n    }\n\n    /// TODO Add check for deposit value\n    function autoUpgrade(\n        bytes memory contractCode,\n        bytes memory contractStorageKey\n    ) public {\n        bytes memory codeStorageKey = contractStorageKey;\n\n        // 1 storage key to change, so 4 bytes\n        bytes memory itemCountBytes = bytes(\"\\x04\");\n        // Key value prefixed with key size in big endian (same for all the evm.accountStorage keys)\n        // Add 1 for encodings\n        uint16 keyLength = uint16(codeStorageKey.length * 4) + 1;\n        // conversion to big endian and\n        uint16 reversedkeyLength = ((keyLength >> 8) | (keyLength << 8));\n\n        // Add 1 for encodings\n        uint16 codeLength = uint16(contractCode.length * 4) + 1;\n        // conversion to big endian and add 1 for encoding\n        uint16 reversedCodeLength = ((codeLength >> 8) | (codeLength << 8));\n\n        bytes memory key = bytes.concat(\n            bytes2(reversedkeyLength),\n            codeStorageKey\n        );\n        bytes memory value = bytes.concat(\n            bytes2(reversedCodeLength),\n            contractCode\n        );\n        bytes memory setStorageCall = bytes.concat(\n            setStorageCallIndex,\n            itemCountBytes,\n            key,\n            value\n        );\n\n        bytes32 preimageHash = PREIMAGE_CONTRACT.notePreimage(setStorageCall);\n\n        // /// If the block count is lower than the minimum allowed, it will pick the minimum\n        // /// allowed automatically.\n        uint32 blockCount = 1;\n        uint256 referendumId = REFERENDA_CONTRACT.submitAfter(\n            rootTrackId,\n            preimageHash,\n            uint32(setStorageCall.length),\n            blockCount\n        );\n\n        /// Size of the call + the transaction metadata (1 byte);\n        uint16 txContentLength = uint16((setStorageCall.length) * 4 + 1);\n        // Because of SCALE Compact encoding we need to have a dynamic size of the\n        // transaction length\n        bytes memory fullLength;\n\n        if (txContentLength >= 64) {\n            // 2 bytes\n            fullLength = abi.encodePacked(\n                ((txContentLength >> 8) | (txContentLength << 8))\n            );\n        } else {\n            // 1 byte\n            fullLength = abi.encodePacked(uint8(txContentLength));\n        }\n\n        bytes memory setStorageTx = bytes.concat(\n            bytes32(uint256(txContentLength)),\n            setStorageCall\n        );\n\n        // /// Submit the proposal\n        // REFERENDA_CONTRACT.submitAfter(rootTrackId, setStorageTx, blockCount);\n\n        // uint256 referendumId = REFERENDA_CONTRACT.referendumCount();\n\n        // /// TODO once the referendumInfo is available\n        // /// Referenda.TrackInfo memory trackInfo = REFERENDA_CONTRACT.referendumInfo(referendumId);\n\n        // /// Directly place the deposit\n        // REFERENDA_CONTRACT.placeDecisionDeposit(uint32(referendumId));\n    }\n}\n\ncontract ReferendaAutoUpgradeDemoV1 is ReferendaAutoUpgradeDemo {\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex)\n        ReferendaAutoUpgradeDemo(trackName, pSetStorageCallIndex)\n    {}\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n}\n\ncontract ReferendaAutoUpgradeDemoV2 is ReferendaAutoUpgradeDemo {\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex)\n        ReferendaAutoUpgradeDemo(trackName, pSetStorageCallIndex)\n    {}\n\n    function version() external pure returns (uint256) {\n        return 2;\n    }\n}\n"
}
