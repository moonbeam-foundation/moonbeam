{
  "byteCode": "0x",
  "contract": {
    "abi": [
      {
        "inputs": [
          { "internalType": "bytes", "name": "contractCode", "type": "bytes" },
          {
            "internalType": "bytes",
            "name": "contractStorageKey",
            "type": "bytes"
          }
        ],
        "name": "autoUpgrade",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "proposalId",
        "outputs": [{ "internalType": "uint16", "name": "", "type": "uint16" }],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "rootTrackId",
        "outputs": [{ "internalType": "uint16", "name": "", "type": "uint16" }],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "setStorageCallIndex",
        "outputs": [{ "internalType": "bytes2", "name": "", "type": "bytes2" }],
        "stateMutability": "view",
        "type": "function"
      }
    ],
    "devdoc": {
      "kind": "dev",
      "methods": {
        "autoUpgrade(bytes,bytes)": {
          "params": {
            "contractCode": "The code as deployed of the new contract",
            "contractStorageKey": "The storage key associated with the current smart contract"
          }
        }
      },
      "version": 1
    },
    "evm": {
      "assembly": "",
      "bytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "deployedBytecode": {
        "functionDebugData": {},
        "generatedSources": [],
        "immutableReferences": {},
        "linkReferences": {},
        "object": "",
        "opcodes": "",
        "sourceMap": ""
      },
      "gasEstimates": null,
      "legacyAssembly": null,
      "methodIdentifiers": {
        "autoUpgrade(bytes,bytes)": "79688e99",
        "proposalId()": "2dfca445",
        "rootTrackId()": "6d72ffb6",
        "setStorageCallIndex()": "920e0c03"
      }
    },
    "ewasm": { "wasm": "" },
    "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"contractCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"contractStorageKey\",\"type\":\"bytes\"}],\"name\":\"autoUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootTrackId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStorageCallIndex\",\"outputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"autoUpgrade(bytes,bytes)\":{\"params\":{\"contractCode\":\"The code as deployed of the new contract\",\"contractStorageKey\":\"The storage key associated with the current smart contract\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"autoUpgrade(bytes,bytes)\":{\"notice\":\"submits to upgrade contract for given storage key\"},\"constructor\":{\"notice\":\"construct the smart contract with the track id to send the proposal to\"},\"proposalId()\":{\"notice\":\"The id of the track used for root execution\"},\"rootTrackId()\":{\"notice\":\"The id of the track used for root execution\"},\"setStorageCallIndex()\":{\"notice\":\"SetStorageCall index (pallet Index concatenated with call index, usually \\\"\\\\x00\\\\x04\\\")\"}},\"notice\":\"Smart contract to demonstrate how to use Referenda Precompile to self-upgrade\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"main.sol\":\"ReferendaAutoUpgradeDemo\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"main.sol\":{\"keccak256\":\"0x5857dc984be4e3a708744a9d668baaf1bbc70247b0a6028b1b71b6a570d88287\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://9176cbd073986de1c52c9bb792ed5ad61c5637e65096d1ed8f2d6cfcb85426ac\",\"dweb:/ipfs/Qmcnw7GXvBFgg2pH8Kk8b3gqq6Di9pPKXfWfCzEEp63STo\"]},\"precompiles/conviction-voting/ConvictionVoting.sol\":{\"keccak256\":\"0x2ee018e2de05f175dc13f1eada66c145ee9b86c79eabcea8475681d840e2374d\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://9f57de4887b65be5bb52e848513bd3471c4275ff6df34d2a647dc421054122b3\",\"dweb:/ipfs/QmYt2F5e6VHUc5MdhsaSsTcZbctSNeUH9ncgCihSx37uc3\"]},\"precompiles/preimage/Preimage.sol\":{\"keccak256\":\"0x8b0a12d239d2226ae5d5d79761b0e66c3aa9bdbe2fb41d512478bbd8b5d516ec\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://8405c679cdc5ecc4725e1869c620910ed303dfdab74a617af60e6b4c6df6ca3e\",\"dweb:/ipfs/QmPsXz13YLPKX2FjaLTZTW1cEBeVL1cKt4GoJewtiHjv2P\"]},\"precompiles/referenda/Referenda.sol\":{\"keccak256\":\"0x3f4ad640fb2fe333c9a24ae203847c3629e9edd7cb87f6722fff8de440c3f6da\",\"license\":\"GPL-3.0-only\",\"urls\":[\"bzz-raw://454133320632006c8dead321ef116befb1d56489c9ac1fe83c937a9833647a0e\",\"dweb:/ipfs/Qmadr6k9LenduFNokz1tWsK4QqQ473ZjqMKuP3qJizFi4W\"]}},\"version\":1}",
    "storageLayout": {
      "storage": [
        {
          "astId": 8,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "rootTrackId",
          "offset": 0,
          "slot": "0",
          "type": "t_uint16"
        },
        {
          "astId": 11,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "setStorageCallIndex",
          "offset": 2,
          "slot": "0",
          "type": "t_bytes2"
        },
        {
          "astId": 14,
          "contract": "main.sol:ReferendaAutoUpgradeDemo",
          "label": "proposalId",
          "offset": 4,
          "slot": "0",
          "type": "t_uint16"
        }
      ],
      "types": {
        "t_bytes2": {
          "encoding": "inplace",
          "label": "bytes2",
          "numberOfBytes": "2"
        },
        "t_uint16": {
          "encoding": "inplace",
          "label": "uint16",
          "numberOfBytes": "2"
        }
      }
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "autoUpgrade(bytes,bytes)": {
          "notice": "submits to upgrade contract for given storage key"
        },
        "constructor": {
          "notice": "construct the smart contract with the track id to send the proposal to"
        },
        "proposalId()": {
          "notice": "The id of the track used for root execution"
        },
        "rootTrackId()": {
          "notice": "The id of the track used for root execution"
        },
        "setStorageCallIndex()": {
          "notice": "SetStorageCall index (pallet Index concatenated with call index, usually \"\\x00\\x04\")"
        }
      },
      "notice": "Smart contract to demonstrate how to use Referenda Precompile to self-upgrade",
      "version": 1
    }
  },
  "sourceCode": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.3;\n\nimport \"../../../precompiles/referenda/Referenda.sol\";\nimport \"../../../precompiles/preimage/Preimage.sol\";\nimport \"../../../precompiles/conviction-voting/ConvictionVoting.sol\";\n\n/// @notice Smart contract to demonstrate how to use Referenda Precompile to self-upgrade\nabstract contract ReferendaAutoUpgradeDemo {\n    /// @notice The id of the track used for root execution\n    uint16 public rootTrackId;\n\n    /// @notice SetStorageCall index (pallet Index concatenated with call index, usually \"\\x00\\x04\")\n    bytes2 public setStorageCallIndex;\n\n    /// @notice The id of the track used for root execution\n    uint16 public proposalId;\n\n    /// @notice construct the smart contract with the track id to send the proposal to\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex) {\n        setStorageCallIndex = pSetStorageCallIndex;\n\n        // This is obviously NOT THE RIGHT WAY to find/store the track id.\n        // The track id should be passed as an argument of the constructor instead of the\n        // track name.\n        // In this demo, it is using the track name to show how to loop through the trackIds.\n        rootTrackId = getTrackId(trackName);\n    }\n\n    /// @notice retrieves the track id matching the track name\n    /// @notice this is ineficient and only used for a demo.\n    function getTrackId(string memory trackName)\n        internal\n        view\n        returns (uint16)\n    {\n        uint16[] memory trackIds = REFERENDA_CONTRACT.trackIds();\n        for (uint256 i = 0; i < trackIds.length; i++) {\n            Referenda.TrackInfo memory info = REFERENDA_CONTRACT.trackInfo(\n                trackIds[i]\n            );\n\n            if (\n                keccak256(abi.encodePacked((info.name))) ==\n                keccak256(abi.encodePacked((trackName))) // Compare the 2 strings\n            ) {\n                return trackIds[i];\n            }\n        }\n        revert(\"Couldn't find track\");\n    }\n\n    /// @notice concatenated bytes of the string, prefixed by the length in big endian\n    function buildSubstrateString(bytes memory value)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // Add 1 for encodings\n        uint16 length = uint16(value.length * 4) + 1;\n        // conversion to big endian\n        uint16 reversedlength = ((length >> 8) | (length << 8));\n        // string prefixed by big endian length\n        return bytes.concat(bytes2(reversedlength), value);\n    }\n\n    /// @notice build the storage key/item\n    function buildSetStorageItem(bytes memory key, bytes memory value)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            bytes.concat(\n                buildSubstrateString(key),\n                buildSubstrateString(value)\n            );\n    }\n\n    /// @notice build the set storage proposal. It includes the setStorage call + the number of\n    /// @notice storages to change and the key/value of each storage.\n    function buildSetStorageProposal(\n        bytes memory contractStorageKey,\n        bytes memory contractCode\n    ) internal view returns (bytes memory) {\n        return\n            bytes.concat(\n                setStorageCallIndex,\n                bytes1(uint8(1 * 4)), // 1 storage item to change, so 4 bytes\n                buildSetStorageItem(contractStorageKey, contractCode)\n            );\n    }\n\n    /// @notice submits to upgrade contract for given storage key\n    /// @param contractCode The code as deployed of the new contract\n    /// @param contractStorageKey The storage key associated with the current smart contract\n    function autoUpgrade(\n        bytes memory contractCode,\n        bytes memory contractStorageKey\n    ) public {\n        bytes memory setStorageCall = buildSetStorageProposal(\n            contractStorageKey,\n            contractCode\n        );\n        bytes32 preimageHash = PREIMAGE_CONTRACT.notePreimage(setStorageCall);\n\n        // /// If the block count is lower than the minimum allowed, it will pick the minimum\n        // /// allowed automatically.\n        uint32 blockCount = 1;\n        uint32 referendumId = REFERENDA_CONTRACT.submitAfter(\n            rootTrackId,\n            preimageHash,\n            uint32(setStorageCall.length),\n            blockCount\n        );\n\n        /// Directly place the deposit\n        REFERENDA_CONTRACT.placeDecisionDeposit(referendumId);\n\n        /// Vote for the referendum\n        CONVICTION_VOTING_CONTRACT.voteYes(\n            referendumId,\n            address(this).balance, // Uses all the contract available balance\n            ConvictionVoting.Conviction.Locked1x\n        );\n    }\n}\n\n/// @notice First version of the contract\ncontract ReferendaAutoUpgradeDemoV1 is ReferendaAutoUpgradeDemo {\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex)\n        ReferendaAutoUpgradeDemo(trackName, pSetStorageCallIndex)\n    {}\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n}\n\n/// @notice Second version of the contract\ncontract ReferendaAutoUpgradeDemoV2 is ReferendaAutoUpgradeDemo {\n    constructor(string memory trackName, bytes2 pSetStorageCallIndex)\n        ReferendaAutoUpgradeDemo(trackName, pSetStorageCallIndex)\n    {}\n\n    function version() external pure returns (uint256) {\n        return 2;\n    }\n}\n"
}
